From 638d002c9482fb275fe9679b0d56ac9196570030 Mon Sep 17 00:00:00 2001
From: sjthales <sebastien.jacq@thalesgroup.com>
Date: Fri, 9 Oct 2020 10:24:36 +0200
Subject: [PATCH] coremark modification

---
 sw/app/coremark/barebones/core_portme.c   | 153 -------
 sw/app/coremark/barebones/core_portme.h   | 210 ---------
 sw/app/coremark/barebones/core_portme.mak |  87 ----
 sw/app/coremark/barebones/cvt.c           | 127 ------
 sw/app/coremark/barebones/ee_printf.c     | 700 ------------------------------
 sw/app/coremark/core_main.c               |   4 +-
 sw/app/coremark/cygwin/core_portme.c      | 420 ------------------
 sw/app/coremark/cygwin/core_portme.h      | 312 -------------
 sw/app/coremark/cygwin/core_portme.mak    | 141 ------
 sw/app/coremark/freebsd/core_portme.c     | 419 ------------------
 sw/app/coremark/freebsd/core_portme.h     | 309 -------------
 sw/app/coremark/freebsd/core_portme.mak   | 140 ------
 sw/app/coremark/linux/core_portme.c       | 422 ------------------
 sw/app/coremark/linux/core_portme.h       | 308 -------------
 sw/app/coremark/linux/core_portme.mak     | 140 ------
 sw/app/coremark/linux64/core_portme.c     | 420 ------------------
 sw/app/coremark/linux64/core_portme.h     | 309 -------------
 sw/app/coremark/linux64/core_portme.mak   | 140 ------
 sw/app/coremark/macos/core_portme.c       | 420 ------------------
 sw/app/coremark/macos/core_portme.h       | 309 -------------
 sw/app/coremark/macos/core_portme.mak     | 140 ------
 sw/app/coremark/rtems/core_portme.c       | 364 ----------------
 sw/app/coremark/rtems/core_portme.h       | 305 -------------
 sw/app/coremark/rtems/core_portme.mak     | 140 ------
 sw/app/coremark/simple/core_portme.c      |   8 +-
 sw/app/coremark/simple/core_portme.h      |  12 +-
 26 files changed, 14 insertions(+), 6445 deletions(-)
 delete mode 100644 sw/app/coremark/barebones/core_portme.c
 delete mode 100644 sw/app/coremark/barebones/core_portme.h
 delete mode 100755 sw/app/coremark/barebones/core_portme.mak
 delete mode 100644 sw/app/coremark/barebones/cvt.c
 delete mode 100644 sw/app/coremark/barebones/ee_printf.c
 delete mode 100644 sw/app/coremark/cygwin/core_portme.c
 delete mode 100644 sw/app/coremark/cygwin/core_portme.h
 delete mode 100755 sw/app/coremark/cygwin/core_portme.mak
 delete mode 100644 sw/app/coremark/freebsd/core_portme.c
 delete mode 100644 sw/app/coremark/freebsd/core_portme.h
 delete mode 100755 sw/app/coremark/freebsd/core_portme.mak
 delete mode 100644 sw/app/coremark/linux/core_portme.c
 delete mode 100644 sw/app/coremark/linux/core_portme.h
 delete mode 100755 sw/app/coremark/linux/core_portme.mak
 delete mode 100644 sw/app/coremark/linux64/core_portme.c
 delete mode 100644 sw/app/coremark/linux64/core_portme.h
 delete mode 100755 sw/app/coremark/linux64/core_portme.mak
 delete mode 100644 sw/app/coremark/macos/core_portme.c
 delete mode 100644 sw/app/coremark/macos/core_portme.h
 delete mode 100755 sw/app/coremark/macos/core_portme.mak
 delete mode 100755 sw/app/coremark/rtems/core_portme.c
 delete mode 100755 sw/app/coremark/rtems/core_portme.h
 delete mode 100755 sw/app/coremark/rtems/core_portme.mak

diff --git a/sw/app/coremark/barebones/core_portme.c b/sw/app/coremark/barebones/core_portme.c
deleted file mode 100644
index 1896767..0000000
--- a/sw/app/coremark/barebones/core_portme.c
+++ /dev/null
@@ -1,153 +0,0 @@
-/*
-Copyright 2018 Embedded Microprocessor Benchmark Consortium (EEMBC)
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-
-Original Author: Shay Gal-on
-*/
-#include "coremark.h"
-#include "core_portme.h"
-
-#if VALIDATION_RUN
-volatile ee_s32 seed1_volatile = 0x3415;
-volatile ee_s32 seed2_volatile = 0x3415;
-volatile ee_s32 seed3_volatile = 0x66;
-#endif
-#if PERFORMANCE_RUN
-volatile ee_s32 seed1_volatile = 0x0;
-volatile ee_s32 seed2_volatile = 0x0;
-volatile ee_s32 seed3_volatile = 0x66;
-#endif
-#if PROFILE_RUN
-volatile ee_s32 seed1_volatile = 0x8;
-volatile ee_s32 seed2_volatile = 0x8;
-volatile ee_s32 seed3_volatile = 0x8;
-#endif
-volatile ee_s32 seed4_volatile = ITERATIONS;
-volatile ee_s32 seed5_volatile = 0;
-/* Porting : Timing functions
-        How to capture time and convert to seconds must be ported to whatever is
-   supported by the platform. e.g. Read value from on board RTC, read value from
-   cpu clock cycles performance counter etc. Sample implementation for standard
-   time.h and windows.h definitions included.
-*/
-CORETIMETYPE
-barebones_clock()
-{
-#error \
-    "You must implement a method to measure time in barebones_clock()! This function should return current time.\n"
-}
-/* Define : TIMER_RES_DIVIDER
-        Divider to trade off timer resolution and total time that can be
-   measured.
-
-        Use lower values to increase resolution, but make sure that overflow
-   does not occur. If there are issues with the return value overflowing,
-   increase this value.
-        */
-#define GETMYTIME(_t)              (*_t = barebones_clock())
-#define MYTIMEDIFF(fin, ini)       ((fin) - (ini))
-#define TIMER_RES_DIVIDER          1
-#define SAMPLE_TIME_IMPLEMENTATION 1
-#define EE_TICKS_PER_SEC           (CLOCKS_PER_SEC / TIMER_RES_DIVIDER)
-
-/** Define Host specific (POSIX), or target specific global time variables. */
-static CORETIMETYPE start_time_val, stop_time_val;
-
-/* Function : start_time
-        This function will be called right before starting the timed portion of
-   the benchmark.
-
-        Implementation may be capturing a system timer (as implemented in the
-   example code) or zeroing some system parameters - e.g. setting the cpu clocks
-   cycles to 0.
-*/
-void
-start_time(void)
-{
-    GETMYTIME(&start_time_val);
-}
-/* Function : stop_time
-        This function will be called right after ending the timed portion of the
-   benchmark.
-
-        Implementation may be capturing a system timer (as implemented in the
-   example code) or other system parameters - e.g. reading the current value of
-   cpu cycles counter.
-*/
-void
-stop_time(void)
-{
-    GETMYTIME(&stop_time_val);
-}
-/* Function : get_time
-        Return an abstract "ticks" number that signifies time on the system.
-
-        Actual value returned may be cpu cycles, milliseconds or any other
-   value, as long as it can be converted to seconds by <time_in_secs>. This
-   methodology is taken to accomodate any hardware or simulated platform. The
-   sample implementation returns millisecs by default, and the resolution is
-   controlled by <TIMER_RES_DIVIDER>
-*/
-CORE_TICKS
-get_time(void)
-{
-    CORE_TICKS elapsed
-        = (CORE_TICKS)(MYTIMEDIFF(stop_time_val, start_time_val));
-    return elapsed;
-}
-/* Function : time_in_secs
-        Convert the value returned by get_time to seconds.
-
-        The <secs_ret> type is used to accomodate systems with no support for
-   floating point. Default implementation implemented by the EE_TICKS_PER_SEC
-   macro above.
-*/
-secs_ret
-time_in_secs(CORE_TICKS ticks)
-{
-    secs_ret retval = ((secs_ret)ticks) / (secs_ret)EE_TICKS_PER_SEC;
-    return retval;
-}
-
-ee_u32 default_num_contexts = 1;
-
-/* Function : portable_init
-        Target specific initialization code
-        Test for some common mistakes.
-*/
-void
-portable_init(core_portable *p, int *argc, char *argv[])
-{
-#error \
-    "Call board initialization routines in portable init (if needed), in particular initialize UART!\n"
-    if (sizeof(ee_ptr_int) != sizeof(ee_u8 *))
-    {
-        ee_printf(
-            "ERROR! Please define ee_ptr_int to a type that holds a "
-            "pointer!\n");
-    }
-    if (sizeof(ee_u32) != 4)
-    {
-        ee_printf("ERROR! Please define ee_u32 to a 32b unsigned type!\n");
-    }
-    p->portable_id = 1;
-}
-/* Function : portable_fini
-        Target specific final code
-*/
-void
-portable_fini(core_portable *p)
-{
-    p->portable_id = 0;
-}
diff --git a/sw/app/coremark/barebones/core_portme.h b/sw/app/coremark/barebones/core_portme.h
deleted file mode 100644
index 55f643b..0000000
--- a/sw/app/coremark/barebones/core_portme.h
+++ /dev/null
@@ -1,210 +0,0 @@
-/*
-Copyright 2018 Embedded Microprocessor Benchmark Consortium (EEMBC)
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-
-Original Author: Shay Gal-on
-*/
-/* Topic : Description
-        This file contains configuration constants required to execute on
-   different platforms
-*/
-#ifndef CORE_PORTME_H
-#define CORE_PORTME_H
-/************************/
-/* Data types and settings */
-/************************/
-/* Configuration : HAS_FLOAT
-        Define to 1 if the platform supports floating point.
-*/
-#ifndef HAS_FLOAT
-#define HAS_FLOAT 1
-#endif
-/* Configuration : HAS_TIME_H
-        Define to 1 if platform has the time.h header file,
-        and implementation of functions thereof.
-*/
-#ifndef HAS_TIME_H
-#define HAS_TIME_H 1
-#endif
-/* Configuration : USE_CLOCK
-        Define to 1 if platform has the time.h header file,
-        and implementation of functions thereof.
-*/
-#ifndef USE_CLOCK
-#define USE_CLOCK 1
-#endif
-/* Configuration : HAS_STDIO
-        Define to 1 if the platform has stdio.h.
-*/
-#ifndef HAS_STDIO
-#define HAS_STDIO 0
-#endif
-/* Configuration : HAS_PRINTF
-        Define to 1 if the platform has stdio.h and implements the printf
-   function.
-*/
-#ifndef HAS_PRINTF
-#define HAS_PRINTF 0
-#endif
-
-/* Definitions : COMPILER_VERSION, COMPILER_FLAGS, MEM_LOCATION
-        Initialize these strings per platform
-*/
-#ifndef COMPILER_VERSION
-#ifdef __GNUC__
-#define COMPILER_VERSION "GCC"__VERSION__
-#else
-#define COMPILER_VERSION "Please put compiler version here (e.g. gcc 4.1)"
-#endif
-#endif
-#ifndef COMPILER_FLAGS
-#define COMPILER_FLAGS \
-    FLAGS_STR /* "Please put compiler flags here (e.g. -o3)" */
-#endif
-#ifndef MEM_LOCATION
-#define MEM_LOCATION "STACK"
-#endif
-
-/* Data Types :
-        To avoid compiler issues, define the data types that need ot be used for
-   8b, 16b and 32b in <core_portme.h>.
-
-        *Imprtant* :
-        ee_ptr_int needs to be the data type used to hold pointers, otherwise
-   coremark may fail!!!
-*/
-typedef signed short   ee_s16;
-typedef unsigned short ee_u16;
-typedef signed int     ee_s32;
-typedef double         ee_f32;
-typedef unsigned char  ee_u8;
-typedef unsigned int   ee_u32;
-typedef ee_u32         ee_ptr_int;
-typedef size_t         ee_size_t;
-#define NULL ((void *)0)
-/* align_mem :
-        This macro is used to align an offset to point to a 32b value. It is
-   used in the Matrix algorithm to initialize the input memory blocks.
-*/
-#define align_mem(x) (void *)(4 + (((ee_ptr_int)(x)-1) & ~3))
-
-/* Configuration : CORE_TICKS
-        Define type of return from the timing functions.
- */
-#define CORETIMETYPE ee_u32
-typedef ee_u32 CORE_TICKS;
-
-/* Configuration : SEED_METHOD
-        Defines method to get seed values that cannot be computed at compile
-   time.
-
-        Valid values :
-        SEED_ARG - from command line.
-        SEED_FUNC - from a system function.
-        SEED_VOLATILE - from volatile variables.
-*/
-#ifndef SEED_METHOD
-#define SEED_METHOD SEED_VOLATILE
-#endif
-
-/* Configuration : MEM_METHOD
-        Defines method to get a block of memry.
-
-        Valid values :
-        MEM_MALLOC - for platforms that implement malloc and have malloc.h.
-        MEM_STATIC - to use a static memory array.
-        MEM_STACK - to allocate the data block on the stack (NYI).
-*/
-#ifndef MEM_METHOD
-#define MEM_METHOD MEM_STACK
-#endif
-
-/* Configuration : MULTITHREAD
-        Define for parallel execution
-
-        Valid values :
-        1 - only one context (default).
-        N>1 - will execute N copies in parallel.
-
-        Note :
-        If this flag is defined to more then 1, an implementation for launching
-   parallel contexts must be defined.
-
-        Two sample implementations are provided. Use <USE_PTHREAD> or <USE_FORK>
-   to enable them.
-
-        It is valid to have a different implementation of <core_start_parallel>
-   and <core_end_parallel> in <core_portme.c>, to fit a particular architecture.
-*/
-#ifndef MULTITHREAD
-#define MULTITHREAD 1
-#define USE_PTHREAD 0
-#define USE_FORK    0
-#define USE_SOCKET  0
-#endif
-
-/* Configuration : MAIN_HAS_NOARGC
-        Needed if platform does not support getting arguments to main.
-
-        Valid values :
-        0 - argc/argv to main is supported
-        1 - argc/argv to main is not supported
-
-        Note :
-        This flag only matters if MULTITHREAD has been defined to a value
-   greater then 1.
-*/
-#ifndef MAIN_HAS_NOARGC
-#define MAIN_HAS_NOARGC 0
-#endif
-
-/* Configuration : MAIN_HAS_NORETURN
-        Needed if platform does not support returning a value from main.
-
-        Valid values :
-        0 - main returns an int, and return value will be 0.
-        1 - platform does not support returning a value from main
-*/
-#ifndef MAIN_HAS_NORETURN
-#define MAIN_HAS_NORETURN 0
-#endif
-
-/* Variable : default_num_contexts
-        Not used for this simple port, must cintain the value 1.
-*/
-extern ee_u32 default_num_contexts;
-
-typedef struct CORE_PORTABLE_S
-{
-    ee_u8 portable_id;
-} core_portable;
-
-/* target specific init/fini */
-void portable_init(core_portable *p, int *argc, char *argv[]);
-void portable_fini(core_portable *p);
-
-#if !defined(PROFILE_RUN) && !defined(PERFORMANCE_RUN) \
-    && !defined(VALIDATION_RUN)
-#if (TOTAL_DATA_SIZE == 1200)
-#define PROFILE_RUN 1
-#elif (TOTAL_DATA_SIZE == 2000)
-#define PERFORMANCE_RUN 1
-#else
-#define VALIDATION_RUN 1
-#endif
-#endif
-
-int ee_printf(const char *fmt, ...);
-
-#endif /* CORE_PORTME_H */
diff --git a/sw/app/coremark/barebones/core_portme.mak b/sw/app/coremark/barebones/core_portme.mak
deleted file mode 100755
index 8159469..0000000
--- a/sw/app/coremark/barebones/core_portme.mak
+++ /dev/null
@@ -1,87 +0,0 @@
-# Copyright 2018 Embedded Microprocessor Benchmark Consortium (EEMBC)
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#    http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-# 
-# Original Author: Shay Gal-on
-
-#File : core_portme.mak
-
-# Flag : OUTFLAG
-#	Use this flag to define how to to get an executable (e.g -o)
-OUTFLAG= -o
-# Flag : CC
-#	Use this flag to define compiler to use
-CC 		= gcc
-# Flag : LD
-#	Use this flag to define compiler to use
-LD		= gld
-# Flag : AS
-#	Use this flag to define compiler to use
-AS		= gas
-# Flag : CFLAGS
-#	Use this flag to define compiler options. Note, you can add compiler options from the command line using XCFLAGS="other flags"
-PORT_CFLAGS = -O0 -g
-FLAGS_STR = "$(PORT_CFLAGS) $(XCFLAGS) $(XLFLAGS) $(LFLAGS_END)"
-CFLAGS = $(PORT_CFLAGS) -I$(PORT_DIR) -I. -DFLAGS_STR=\"$(FLAGS_STR)\" 
-#Flag : LFLAGS_END
-#	Define any libraries needed for linking or other flags that should come at the end of the link line (e.g. linker scripts). 
-#	Note : On certain platforms, the default clock_gettime implementation is supported but requires linking of librt.
-SEPARATE_COMPILE=1
-# Flag : SEPARATE_COMPILE
-# You must also define below how to create an object file, and how to link.
-OBJOUT 	= -o
-LFLAGS 	= 
-ASFLAGS =
-OFLAG 	= -o
-COUT 	= -c
-
-LFLAGS_END = 
-# Flag : PORT_SRCS
-# 	Port specific source files can be added here
-#	You may also need cvt.c if the fcvt functions are not provided as intrinsics by your compiler!
-PORT_SRCS = $(PORT_DIR)/core_portme.c $(PORT_DIR)/ee_printf.c
-vpath %.c $(PORT_DIR)
-vpath %.s $(PORT_DIR)
-
-# Flag : LOAD
-#	For a simple port, we assume self hosted compile and run, no load needed.
-
-# Flag : RUN
-#	For a simple port, we assume self hosted compile and run, simple invocation of the executable
-
-LOAD = echo "Please set LOAD to the process of loading the executable to the flash"
-RUN = echo "Please set LOAD to the process of running the executable (e.g. via jtag, or board reset)"
-
-OEXT = .o
-EXE = .bin
-
-$(OPATH)$(PORT_DIR)/%$(OEXT) : %.c
-	$(CC) $(CFLAGS) $(XCFLAGS) $(COUT) $< $(OBJOUT) $@
-
-$(OPATH)%$(OEXT) : %.c
-	$(CC) $(CFLAGS) $(XCFLAGS) $(COUT) $< $(OBJOUT) $@
-
-$(OPATH)$(PORT_DIR)/%$(OEXT) : %.s
-	$(AS) $(ASFLAGS) $< $(OBJOUT) $@
-
-# Target : port_pre% and port_post%
-# For the purpose of this simple port, no pre or post steps needed.
-
-.PHONY : port_prebuild port_postbuild port_prerun port_postrun port_preload port_postload
-port_pre% port_post% : 
-
-# FLAG : OPATH
-# Path to the output folder. Default - current folder.
-OPATH = ./
-MKDIR = mkdir -p
-
diff --git a/sw/app/coremark/barebones/cvt.c b/sw/app/coremark/barebones/cvt.c
deleted file mode 100644
index 333e8ea..0000000
--- a/sw/app/coremark/barebones/cvt.c
+++ /dev/null
@@ -1,127 +0,0 @@
-/*
-Copyright 2018 Embedded Microprocessor Benchmark Consortium (EEMBC)
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-#include <math.h>
-#define CVTBUFSIZE 80
-static char CVTBUF[CVTBUFSIZE];
-
-static char *
-cvt(double arg, int ndigits, int *decpt, int *sign, char *buf, int eflag)
-{
-    int    r2;
-    double fi, fj;
-    char * p, *p1;
-
-    if (ndigits < 0)
-        ndigits = 0;
-    if (ndigits >= CVTBUFSIZE - 1)
-        ndigits = CVTBUFSIZE - 2;
-    r2    = 0;
-    *sign = 0;
-    p     = &buf[0];
-    if (arg < 0)
-    {
-        *sign = 1;
-        arg   = -arg;
-    }
-    arg = modf(arg, &fi);
-    p1  = &buf[CVTBUFSIZE];
-
-    if (fi != 0)
-    {
-        p1 = &buf[CVTBUFSIZE];
-        while (fi != 0)
-        {
-            fj    = modf(fi / 10, &fi);
-            *--p1 = (int)((fj + .03) * 10) + '0';
-            r2++;
-        }
-        while (p1 < &buf[CVTBUFSIZE])
-            *p++ = *p1++;
-    }
-    else if (arg > 0)
-    {
-        while ((fj = arg * 10) < 1)
-        {
-            arg = fj;
-            r2--;
-        }
-    }
-    p1 = &buf[ndigits];
-    if (eflag == 0)
-        p1 += r2;
-    *decpt = r2;
-    if (p1 < &buf[0])
-    {
-        buf[0] = '\0';
-        return buf;
-    }
-    while (p <= p1 && p < &buf[CVTBUFSIZE])
-    {
-        arg *= 10;
-        arg  = modf(arg, &fj);
-        *p++ = (int)fj + '0';
-    }
-    if (p1 >= &buf[CVTBUFSIZE])
-    {
-        buf[CVTBUFSIZE - 1] = '\0';
-        return buf;
-    }
-    p = p1;
-    *p1 += 5;
-    while (*p1 > '9')
-    {
-        *p1 = '0';
-        if (p1 > buf)
-            ++*--p1;
-        else
-        {
-            *p1 = '1';
-            (*decpt)++;
-            if (eflag == 0)
-            {
-                if (p > buf)
-                    *p = '0';
-                p++;
-            }
-        }
-    }
-    *p = '\0';
-    return buf;
-}
-
-char *
-ecvt(double arg, int ndigits, int *decpt, int *sign)
-{
-    return cvt(arg, ndigits, decpt, sign, CVTBUF, 1);
-}
-
-char *
-ecvtbuf(double arg, int ndigits, int *decpt, int *sign, char *buf)
-{
-    return cvt(arg, ndigits, decpt, sign, buf, 1);
-}
-
-char *
-fcvt(double arg, int ndigits, int *decpt, int *sign)
-{
-    return cvt(arg, ndigits, decpt, sign, CVTBUF, 0);
-}
-
-char *
-fcvtbuf(double arg, int ndigits, int *decpt, int *sign, char *buf)
-{
-    return cvt(arg, ndigits, decpt, sign, buf, 0);
-}
diff --git a/sw/app/coremark/barebones/ee_printf.c b/sw/app/coremark/barebones/ee_printf.c
deleted file mode 100644
index 88d8a62..0000000
--- a/sw/app/coremark/barebones/ee_printf.c
+++ /dev/null
@@ -1,700 +0,0 @@
-/*
-Copyright 2018 Embedded Microprocessor Benchmark Consortium (EEMBC)
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-#include <coremark.h>
-#include <stdarg.h>
-
-#define ZEROPAD   (1 << 0) /* Pad with zero */
-#define SIGN      (1 << 1) /* Unsigned/signed long */
-#define PLUS      (1 << 2) /* Show plus */
-#define SPACE     (1 << 3) /* Spacer */
-#define LEFT      (1 << 4) /* Left justified */
-#define HEX_PREP  (1 << 5) /* 0x */
-#define UPPERCASE (1 << 6) /* 'ABCDEF' */
-
-#define is_digit(c) ((c) >= '0' && (c) <= '9')
-
-static char *    digits       = "0123456789abcdefghijklmnopqrstuvwxyz";
-static char *    upper_digits = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
-static ee_size_t strnlen(const char *s, ee_size_t count);
-
-static ee_size_t
-strnlen(const char *s, ee_size_t count)
-{
-    const char *sc;
-    for (sc = s; *sc != '\0' && count--; ++sc)
-        ;
-    return sc - s;
-}
-
-static int
-skip_atoi(const char **s)
-{
-    int i = 0;
-    while (is_digit(**s))
-        i = i * 10 + *((*s)++) - '0';
-    return i;
-}
-
-static char *
-number(char *str, long num, int base, int size, int precision, int type)
-{
-    char  c, sign, tmp[66];
-    char *dig = digits;
-    int   i;
-
-    if (type & UPPERCASE)
-        dig = upper_digits;
-    if (type & LEFT)
-        type &= ~ZEROPAD;
-    if (base < 2 || base > 36)
-        return 0;
-
-    c    = (type & ZEROPAD) ? '0' : ' ';
-    sign = 0;
-    if (type & SIGN)
-    {
-        if (num < 0)
-        {
-            sign = '-';
-            num  = -num;
-            size--;
-        }
-        else if (type & PLUS)
-        {
-            sign = '+';
-            size--;
-        }
-        else if (type & SPACE)
-        {
-            sign = ' ';
-            size--;
-        }
-    }
-
-    if (type & HEX_PREP)
-    {
-        if (base == 16)
-            size -= 2;
-        else if (base == 8)
-            size--;
-    }
-
-    i = 0;
-
-    if (num == 0)
-        tmp[i++] = '0';
-    else
-    {
-        while (num != 0)
-        {
-            tmp[i++] = dig[((unsigned long)num) % (unsigned)base];
-            num      = ((unsigned long)num) / (unsigned)base;
-        }
-    }
-
-    if (i > precision)
-        precision = i;
-    size -= precision;
-    if (!(type & (ZEROPAD | LEFT)))
-        while (size-- > 0)
-            *str++ = ' ';
-    if (sign)
-        *str++ = sign;
-
-    if (type & HEX_PREP)
-    {
-        if (base == 8)
-            *str++ = '0';
-        else if (base == 16)
-        {
-            *str++ = '0';
-            *str++ = digits[33];
-        }
-    }
-
-    if (!(type & LEFT))
-        while (size-- > 0)
-            *str++ = c;
-    while (i < precision--)
-        *str++ = '0';
-    while (i-- > 0)
-        *str++ = tmp[i];
-    while (size-- > 0)
-        *str++ = ' ';
-
-    return str;
-}
-
-static char *
-eaddr(char *str, unsigned char *addr, int size, int precision, int type)
-{
-    char  tmp[24];
-    char *dig = digits;
-    int   i, len;
-
-    if (type & UPPERCASE)
-        dig = upper_digits;
-    len = 0;
-    for (i = 0; i < 6; i++)
-    {
-        if (i != 0)
-            tmp[len++] = ':';
-        tmp[len++] = dig[addr[i] >> 4];
-        tmp[len++] = dig[addr[i] & 0x0F];
-    }
-
-    if (!(type & LEFT))
-        while (len < size--)
-            *str++ = ' ';
-    for (i = 0; i < len; ++i)
-        *str++ = tmp[i];
-    while (len < size--)
-        *str++ = ' ';
-
-    return str;
-}
-
-static char *
-iaddr(char *str, unsigned char *addr, int size, int precision, int type)
-{
-    char tmp[24];
-    int  i, n, len;
-
-    len = 0;
-    for (i = 0; i < 4; i++)
-    {
-        if (i != 0)
-            tmp[len++] = '.';
-        n = addr[i];
-
-        if (n == 0)
-            tmp[len++] = digits[0];
-        else
-        {
-            if (n >= 100)
-            {
-                tmp[len++] = digits[n / 100];
-                n          = n % 100;
-                tmp[len++] = digits[n / 10];
-                n          = n % 10;
-            }
-            else if (n >= 10)
-            {
-                tmp[len++] = digits[n / 10];
-                n          = n % 10;
-            }
-
-            tmp[len++] = digits[n];
-        }
-    }
-
-    if (!(type & LEFT))
-        while (len < size--)
-            *str++ = ' ';
-    for (i = 0; i < len; ++i)
-        *str++ = tmp[i];
-    while (len < size--)
-        *str++ = ' ';
-
-    return str;
-}
-
-#if HAS_FLOAT
-
-char *      ecvtbuf(double arg, int ndigits, int *decpt, int *sign, char *buf);
-char *      fcvtbuf(double arg, int ndigits, int *decpt, int *sign, char *buf);
-static void ee_bufcpy(char *d, char *s, int count);
-
-void
-ee_bufcpy(char *pd, char *ps, int count)
-{
-    char *pe = ps + count;
-    while (ps != pe)
-        *pd++ = *ps++;
-}
-
-static void
-parse_float(double value, char *buffer, char fmt, int precision)
-{
-    int   decpt, sign, exp, pos;
-    char *digits = NULL;
-    char  cvtbuf[80];
-    int   capexp = 0;
-    int   magnitude;
-
-    if (fmt == 'G' || fmt == 'E')
-    {
-        capexp = 1;
-        fmt += 'a' - 'A';
-    }
-
-    if (fmt == 'g')
-    {
-        digits    = ecvtbuf(value, precision, &decpt, &sign, cvtbuf);
-        magnitude = decpt - 1;
-        if (magnitude < -4 || magnitude > precision - 1)
-        {
-            fmt = 'e';
-            precision -= 1;
-        }
-        else
-        {
-            fmt = 'f';
-            precision -= decpt;
-        }
-    }
-
-    if (fmt == 'e')
-    {
-        digits = ecvtbuf(value, precision + 1, &decpt, &sign, cvtbuf);
-
-        if (sign)
-            *buffer++ = '-';
-        *buffer++ = *digits;
-        if (precision > 0)
-            *buffer++ = '.';
-        ee_bufcpy(buffer, digits + 1, precision);
-        buffer += precision;
-        *buffer++ = capexp ? 'E' : 'e';
-
-        if (decpt == 0)
-        {
-            if (value == 0.0)
-                exp = 0;
-            else
-                exp = -1;
-        }
-        else
-            exp = decpt - 1;
-
-        if (exp < 0)
-        {
-            *buffer++ = '-';
-            exp       = -exp;
-        }
-        else
-            *buffer++ = '+';
-
-        buffer[2] = (exp % 10) + '0';
-        exp       = exp / 10;
-        buffer[1] = (exp % 10) + '0';
-        exp       = exp / 10;
-        buffer[0] = (exp % 10) + '0';
-        buffer += 3;
-    }
-    else if (fmt == 'f')
-    {
-        digits = fcvtbuf(value, precision, &decpt, &sign, cvtbuf);
-        if (sign)
-            *buffer++ = '-';
-        if (*digits)
-        {
-            if (decpt <= 0)
-            {
-                *buffer++ = '0';
-                *buffer++ = '.';
-                for (pos = 0; pos < -decpt; pos++)
-                    *buffer++ = '0';
-                while (*digits)
-                    *buffer++ = *digits++;
-            }
-            else
-            {
-                pos = 0;
-                while (*digits)
-                {
-                    if (pos++ == decpt)
-                        *buffer++ = '.';
-                    *buffer++ = *digits++;
-                }
-            }
-        }
-        else
-        {
-            *buffer++ = '0';
-            if (precision > 0)
-            {
-                *buffer++ = '.';
-                for (pos = 0; pos < precision; pos++)
-                    *buffer++ = '0';
-            }
-        }
-    }
-
-    *buffer = '\0';
-}
-
-static void
-decimal_point(char *buffer)
-{
-    while (*buffer)
-    {
-        if (*buffer == '.')
-            return;
-        if (*buffer == 'e' || *buffer == 'E')
-            break;
-        buffer++;
-    }
-
-    if (*buffer)
-    {
-        int n = strnlen(buffer, 256);
-        while (n > 0)
-        {
-            buffer[n + 1] = buffer[n];
-            n--;
-        }
-
-        *buffer = '.';
-    }
-    else
-    {
-        *buffer++ = '.';
-        *buffer   = '\0';
-    }
-}
-
-static void
-cropzeros(char *buffer)
-{
-    char *stop;
-
-    while (*buffer && *buffer != '.')
-        buffer++;
-    if (*buffer++)
-    {
-        while (*buffer && *buffer != 'e' && *buffer != 'E')
-            buffer++;
-        stop = buffer--;
-        while (*buffer == '0')
-            buffer--;
-        if (*buffer == '.')
-            buffer--;
-        while (buffer != stop)
-            *++buffer = 0;
-    }
-}
-
-static char *
-flt(char *str, double num, int size, int precision, char fmt, int flags)
-{
-    char tmp[80];
-    char c, sign;
-    int  n, i;
-
-    // Left align means no zero padding
-    if (flags & LEFT)
-        flags &= ~ZEROPAD;
-
-    // Determine padding and sign char
-    c    = (flags & ZEROPAD) ? '0' : ' ';
-    sign = 0;
-    if (flags & SIGN)
-    {
-        if (num < 0.0)
-        {
-            sign = '-';
-            num  = -num;
-            size--;
-        }
-        else if (flags & PLUS)
-        {
-            sign = '+';
-            size--;
-        }
-        else if (flags & SPACE)
-        {
-            sign = ' ';
-            size--;
-        }
-    }
-
-    // Compute the precision value
-    if (precision < 0)
-        precision = 6; // Default precision: 6
-
-    // Convert floating point number to text
-    parse_float(num, tmp, fmt, precision);
-
-    if ((flags & HEX_PREP) && precision == 0)
-        decimal_point(tmp);
-    if (fmt == 'g' && !(flags & HEX_PREP))
-        cropzeros(tmp);
-
-    n = strnlen(tmp, 256);
-
-    // Output number with alignment and padding
-    size -= n;
-    if (!(flags & (ZEROPAD | LEFT)))
-        while (size-- > 0)
-            *str++ = ' ';
-    if (sign)
-        *str++ = sign;
-    if (!(flags & LEFT))
-        while (size-- > 0)
-            *str++ = c;
-    for (i = 0; i < n; i++)
-        *str++ = tmp[i];
-    while (size-- > 0)
-        *str++ = ' ';
-
-    return str;
-}
-
-#endif
-
-static int
-ee_vsprintf(char *buf, const char *fmt, va_list args)
-{
-    int           len;
-    unsigned long num;
-    int           i, base;
-    char *        str;
-    char *        s;
-
-    int flags; // Flags to number()
-
-    int field_width; // Width of output field
-    int precision;   // Min. # of digits for integers; max number of chars for
-                     // from string
-    int qualifier;   // 'h', 'l', or 'L' for integer fields
-
-    for (str = buf; *fmt; fmt++)
-    {
-        if (*fmt != '%')
-        {
-            *str++ = *fmt;
-            continue;
-        }
-
-        // Process flags
-        flags = 0;
-    repeat:
-        fmt++; // This also skips first '%'
-        switch (*fmt)
-        {
-            case '-':
-                flags |= LEFT;
-                goto repeat;
-            case '+':
-                flags |= PLUS;
-                goto repeat;
-            case ' ':
-                flags |= SPACE;
-                goto repeat;
-            case '#':
-                flags |= HEX_PREP;
-                goto repeat;
-            case '0':
-                flags |= ZEROPAD;
-                goto repeat;
-        }
-
-        // Get field width
-        field_width = -1;
-        if (is_digit(*fmt))
-            field_width = skip_atoi(&fmt);
-        else if (*fmt == '*')
-        {
-            fmt++;
-            field_width = va_arg(args, int);
-            if (field_width < 0)
-            {
-                field_width = -field_width;
-                flags |= LEFT;
-            }
-        }
-
-        // Get the precision
-        precision = -1;
-        if (*fmt == '.')
-        {
-            ++fmt;
-            if (is_digit(*fmt))
-                precision = skip_atoi(&fmt);
-            else if (*fmt == '*')
-            {
-                ++fmt;
-                precision = va_arg(args, int);
-            }
-            if (precision < 0)
-                precision = 0;
-        }
-
-        // Get the conversion qualifier
-        qualifier = -1;
-        if (*fmt == 'l' || *fmt == 'L')
-        {
-            qualifier = *fmt;
-            fmt++;
-        }
-
-        // Default base
-        base = 10;
-
-        switch (*fmt)
-        {
-            case 'c':
-                if (!(flags & LEFT))
-                    while (--field_width > 0)
-                        *str++ = ' ';
-                *str++ = (unsigned char)va_arg(args, int);
-                while (--field_width > 0)
-                    *str++ = ' ';
-                continue;
-
-            case 's':
-                s = va_arg(args, char *);
-                if (!s)
-                    s = "<NULL>";
-                len = strnlen(s, precision);
-                if (!(flags & LEFT))
-                    while (len < field_width--)
-                        *str++ = ' ';
-                for (i = 0; i < len; ++i)
-                    *str++ = *s++;
-                while (len < field_width--)
-                    *str++ = ' ';
-                continue;
-
-            case 'p':
-                if (field_width == -1)
-                {
-                    field_width = 2 * sizeof(void *);
-                    flags |= ZEROPAD;
-                }
-                str = number(str,
-                             (unsigned long)va_arg(args, void *),
-                             16,
-                             field_width,
-                             precision,
-                             flags);
-                continue;
-
-            case 'A':
-                flags |= UPPERCASE;
-
-            case 'a':
-                if (qualifier == 'l')
-                    str = eaddr(str,
-                                va_arg(args, unsigned char *),
-                                field_width,
-                                precision,
-                                flags);
-                else
-                    str = iaddr(str,
-                                va_arg(args, unsigned char *),
-                                field_width,
-                                precision,
-                                flags);
-                continue;
-
-            // Integer number formats - set up the flags and "break"
-            case 'o':
-                base = 8;
-                break;
-
-            case 'X':
-                flags |= UPPERCASE;
-
-            case 'x':
-                base = 16;
-                break;
-
-            case 'd':
-            case 'i':
-                flags |= SIGN;
-
-            case 'u':
-                break;
-
-#if HAS_FLOAT
-
-            case 'f':
-                str = flt(str,
-                          va_arg(args, double),
-                          field_width,
-                          precision,
-                          *fmt,
-                          flags | SIGN);
-                continue;
-
-#endif
-
-            default:
-                if (*fmt != '%')
-                    *str++ = '%';
-                if (*fmt)
-                    *str++ = *fmt;
-                else
-                    --fmt;
-                continue;
-        }
-
-        if (qualifier == 'l')
-            num = va_arg(args, unsigned long);
-        else if (flags & SIGN)
-            num = va_arg(args, int);
-        else
-            num = va_arg(args, unsigned int);
-
-        str = number(str, num, base, field_width, precision, flags);
-    }
-
-    *str = '\0';
-    return str - buf;
-}
-
-void
-uart_send_char(char c)
-{
-#error "You must implement the method uart_send_char to use this file!\n";
-    /*	Output of a char to a UART usually follows the following model:
-            Wait until UART is ready
-            Write char to UART
-            Wait until UART is done
-
-            Or in code:
-            while (*UART_CONTROL_ADDRESS != UART_READY);
-            *UART_DATA_ADDRESS = c;
-            while (*UART_CONTROL_ADDRESS != UART_READY);
-
-            Check the UART sample code on your platform or the board
-       documentation.
-    */
-}
-
-int
-ee_printf(const char *fmt, ...)
-{
-    char    buf[256], *p;
-    va_list args;
-    int     n = 0;
-
-    va_start(args, fmt);
-    ee_vsprintf(buf, fmt, args);
-    va_end(args);
-    p = buf;
-    while (*p)
-    {
-        uart_send_char(*p);
-        n++;
-        p++;
-    }
-
-    return n;
-}
diff --git a/sw/app/coremark/core_main.c b/sw/app/coremark/core_main.c
index 356f4e8..3e53b15 100644
--- a/sw/app/coremark/core_main.c
+++ b/sw/app/coremark/core_main.c
@@ -370,12 +370,12 @@ for (i = 0; i < MULTITHREAD; i++)
                   default_num_contexts * results[0].iterations
                       / time_in_secs(total_time));
 #endif
-    if (time_in_secs(total_time) < 10)
+    /*if (time_in_secs(total_time) < 10)
     {
         ee_printf(
             "ERROR! Must execute for at least 10 secs for a valid result!\n");
         total_errors++;
-    }
+    }*/
 
     ee_printf("Iterations       : %lu\n",
               (long unsigned)default_num_contexts * results[0].iterations);
diff --git a/sw/app/coremark/cygwin/core_portme.c b/sw/app/coremark/cygwin/core_portme.c
deleted file mode 100644
index 00b618c..0000000
--- a/sw/app/coremark/cygwin/core_portme.c
+++ /dev/null
@@ -1,420 +0,0 @@
-/*
-Copyright 2018 Embedded Microprocessor Benchmark Consortium (EEMBC)
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-
-Original Author: Shay Gal-on
-*/
-
-#include <stdio.h>
-#include <stdlib.h>
-#include "coremark.h"
-#if CALLGRIND_RUN
-#include <valgrind/callgrind.h>
-#endif
-
-#if (MEM_METHOD == MEM_MALLOC)
-#include <malloc.h>
-/* Function: portable_malloc
-        Provide malloc() functionality in a platform specific way.
-*/
-void *
-portable_malloc(size_t size)
-{
-    return malloc(size);
-}
-/* Function: portable_free
-        Provide free() functionality in a platform specific way.
-*/
-void
-portable_free(void *p)
-{
-    free(p);
-}
-#else
-void *
-portable_malloc(size_t size)
-{
-    return NULL;
-}
-void
-portable_free(void *p)
-{
-    p = NULL;
-}
-#endif
-
-#if (SEED_METHOD == SEED_VOLATILE)
-#if VALIDATION_RUN
-volatile ee_s32 seed1_volatile = 0x3415;
-volatile ee_s32 seed2_volatile = 0x3415;
-volatile ee_s32 seed3_volatile = 0x66;
-#endif
-#if PERFORMANCE_RUN
-volatile ee_s32 seed1_volatile = 0x0;
-volatile ee_s32 seed2_volatile = 0x0;
-volatile ee_s32 seed3_volatile = 0x66;
-#endif
-#if PROFILE_RUN
-volatile ee_s32 seed1_volatile = 0x8;
-volatile ee_s32 seed2_volatile = 0x8;
-volatile ee_s32 seed3_volatile = 0x8;
-#endif
-volatile ee_s32 seed4_volatile = ITERATIONS;
-volatile ee_s32 seed5_volatile = 0;
-#endif
-/* Porting: Timing functions
-        How to capture time and convert to seconds must be ported to whatever is
-   supported by the platform. e.g. Read value from on board RTC, read value from
-   cpu clock cycles performance counter etc. Sample implementation for standard
-   time.h and windows.h definitions included.
-*/
-/* Define: TIMER_RES_DIVIDER
-        Divider to trade off timer resolution and total time that can be
-   measured.
-
-        Use lower values to increase resolution, but make sure that overflow
-   does not occur. If there are issues with the return value overflowing,
-   increase this value.
-        */
-#if USE_CLOCK
-#define NSECS_PER_SEC              CLOCKS_PER_SEC
-#define EE_TIMER_TICKER_RATE       1000
-#define CORETIMETYPE               clock_t
-#define GETMYTIME(_t)              (*_t = clock())
-#define MYTIMEDIFF(fin, ini)       ((fin) - (ini))
-#define TIMER_RES_DIVIDER          1
-#define SAMPLE_TIME_IMPLEMENTATION 1
-#elif defined(_MSC_VER)
-#define NSECS_PER_SEC        10000000
-#define EE_TIMER_TICKER_RATE 1000
-#define CORETIMETYPE         FILETIME
-#define GETMYTIME(_t)        GetSystemTimeAsFileTime(_t)
-#define MYTIMEDIFF(fin, ini) \
-    (((*(__int64 *)&fin) - (*(__int64 *)&ini)) / TIMER_RES_DIVIDER)
-/* setting to millisces resolution by default with MSDEV */
-#ifndef TIMER_RES_DIVIDER
-#define TIMER_RES_DIVIDER 1000
-#endif
-#define SAMPLE_TIME_IMPLEMENTATION 1
-#elif HAS_TIME_H
-#define NSECS_PER_SEC        1000000000
-#define EE_TIMER_TICKER_RATE 1000
-#define CORETIMETYPE         struct timespec
-#define GETMYTIME(_t)        clock_gettime(CLOCK_REALTIME, _t)
-#define MYTIMEDIFF(fin, ini)                                         \
-    ((fin.tv_sec - ini.tv_sec) * (NSECS_PER_SEC / TIMER_RES_DIVIDER) \
-     + (fin.tv_nsec - ini.tv_nsec) / TIMER_RES_DIVIDER)
-/* setting to 1/1000 of a second resolution by default with linux */
-#ifndef TIMER_RES_DIVIDER
-#define TIMER_RES_DIVIDER 1000000
-#endif
-#define SAMPLE_TIME_IMPLEMENTATION 1
-#else
-#define SAMPLE_TIME_IMPLEMENTATION 0
-#endif
-#define EE_TICKS_PER_SEC (NSECS_PER_SEC / TIMER_RES_DIVIDER)
-
-#if SAMPLE_TIME_IMPLEMENTATION
-/** Define Host specific (POSIX), or target specific global time variables. */
-static CORETIMETYPE start_time_val, stop_time_val;
-
-/* Function: start_time
-        This function will be called right before starting the timed portion of
-   the benchmark.
-
-        Implementation may be capturing a system timer (as implemented in the
-   example code) or zeroing some system parameters - e.g. setting the cpu clocks
-   cycles to 0.
-*/
-void
-start_time(void)
-{
-    GETMYTIME(&start_time_val);
-#if CALLGRIND_RUN
-    CALLGRIND_START_INSTRUMENTATION
-#endif
-#if MICA
-    asm volatile("int3"); /*1 */
-#endif
-}
-/* Function: stop_time
-        This function will be called right after ending the timed portion of the
-   benchmark.
-
-        Implementation may be capturing a system timer (as implemented in the
-   example code) or other system parameters - e.g. reading the current value of
-   cpu cycles counter.
-*/
-void
-stop_time(void)
-{
-#if CALLGRIND_RUN
-    CALLGRIND_STOP_INSTRUMENTATION
-#endif
-#if MICA
-    asm volatile("int3"); /*1 */
-#endif
-    GETMYTIME(&stop_time_val);
-}
-/* Function: get_time
-        Return an abstract "ticks" number that signifies time on the system.
-
-        Actual value returned may be cpu cycles, milliseconds or any other
-   value, as long as it can be converted to seconds by <time_in_secs>. This
-   methodology is taken to accomodate any hardware or simulated platform. The
-   sample implementation returns millisecs by default, and the resolution is
-   controlled by <TIMER_RES_DIVIDER>
-*/
-CORE_TICKS
-get_time(void)
-{
-    CORE_TICKS elapsed
-        = (CORE_TICKS)(MYTIMEDIFF(stop_time_val, start_time_val));
-    return elapsed;
-}
-/* Function: time_in_secs
-        Convert the value returned by get_time to seconds.
-
-        The <secs_ret> type is used to accomodate systems with no support for
-   floating point. Default implementation implemented by the EE_TICKS_PER_SEC
-   macro above.
-*/
-secs_ret
-time_in_secs(CORE_TICKS ticks)
-{
-    secs_ret retval = ((secs_ret)ticks) / (secs_ret)EE_TICKS_PER_SEC;
-    return retval;
-}
-#else
-#error "Please implement timing functionality in core_portme.c"
-#endif /* SAMPLE_TIME_IMPLEMENTATION */
-
-ee_u32 default_num_contexts = MULTITHREAD;
-
-/* Function: portable_init
-        Target specific initialization code
-        Test for some common mistakes.
-*/
-void
-portable_init(core_portable *p, int *argc, char *argv[])
-{
-#if PRINT_ARGS
-    int i;
-    for (i = 0; i < *argc; i++)
-    {
-        ee_printf("Arg[%d]=%s\n", i, argv[i]);
-    }
-#endif
-    if (sizeof(ee_ptr_int) != sizeof(ee_u8 *))
-    {
-        ee_printf(
-            "ERROR! Please define ee_ptr_int to a type that holds a "
-            "pointer!\n");
-    }
-    if (sizeof(ee_u32) != 4)
-    {
-        ee_printf("ERROR! Please define ee_u32 to a 32b unsigned type!\n");
-    }
-#if (MAIN_HAS_NOARGC && (SEED_METHOD == SEED_ARG))
-    ee_printf(
-        "ERROR! Main has no argc, but SEED_METHOD defined to SEED_ARG!\n");
-#endif
-
-#if (MULTITHREAD > 1) && (SEED_METHOD == SEED_ARG)
-    int nargs = *argc, i;
-    if ((nargs > 1) && (*argv[1] == 'M'))
-    {
-        default_num_contexts = parseval(argv[1] + 1);
-        if (default_num_contexts > MULTITHREAD)
-            default_num_contexts = MULTITHREAD;
-        /* Shift args since first arg is directed to the portable part and not
-         * to coremark main */
-        --nargs;
-        for (i = 1; i < nargs; i++)
-            argv[i] = argv[i + 1];
-        *argc = nargs;
-    }
-#endif /* sample of potential platform specific init via command line, reset \
-          the number of contexts being used if first argument is M<n>*/
-    p->portable_id = 1;
-}
-/* Function: portable_fini
-        Target specific final code
-*/
-void
-portable_fini(core_portable *p)
-{
-    p->portable_id = 0;
-}
-
-#if (MULTITHREAD > 1)
-
-/* Function: core_start_parallel
-        Start benchmarking in a parallel context.
-
-        Three implementations are provided, one using pthreads, one using fork
-   and shared mem, and one using fork and sockets. Other implementations using
-   MCAPI or other standards can easily be devised.
-*/
-/* Function: core_stop_parallel
-        Stop a parallel context execution of coremark, and gather the results.
-
-        Three implementations are provided, one using pthreads, one using fork
-   and shared mem, and one using fork and sockets. Other implementations using
-   MCAPI or other standards can easily be devised.
-*/
-#if USE_PTHREAD
-ee_u8
-core_start_parallel(core_results *res)
-{
-    return (ee_u8)pthread_create(
-        &(res->port.thread), NULL, iterate, (void *)res);
-}
-ee_u8
-core_stop_parallel(core_results *res)
-{
-    void *retval;
-    return (ee_u8)pthread_join(res->port.thread, &retval);
-}
-#elif USE_FORK
-static int key_id = 0;
-ee_u8
-core_start_parallel(core_results *res)
-{
-    key_t key = 4321 + key_id;
-    key_id++;
-    res->port.pid   = fork();
-    res->port.shmid = shmget(key, 8, IPC_CREAT | 0666);
-    if (res->port.shmid < 0)
-    {
-        ee_printf("ERROR in shmget!\n");
-    }
-    if (res->port.pid == 0)
-    {
-        iterate(res);
-        res->port.shm = shmat(res->port.shmid, NULL, 0);
-        /* copy the validation values to the shared memory area  and quit*/
-        if (res->port.shm == (char *)-1)
-        {
-            ee_printf("ERROR in child shmat!\n");
-        }
-        else
-        {
-            memcpy(res->port.shm, &(res->crc), 8);
-            shmdt(res->port.shm);
-        }
-        exit(0);
-    }
-    return 1;
-}
-ee_u8
-core_stop_parallel(core_results *res)
-{
-    int   status;
-    pid_t wpid = waitpid(res->port.pid, &status, WUNTRACED);
-    if (wpid != res->port.pid)
-    {
-        ee_printf("ERROR waiting for child.\n");
-        if (errno == ECHILD)
-            ee_printf("errno=No such child %d\n", res->port.pid);
-        if (errno == EINTR)
-            ee_printf("errno=Interrupted\n");
-        return 0;
-    }
-    /* after process is done, get the values from the shared memory area */
-    res->port.shm = shmat(res->port.shmid, NULL, 0);
-    if (res->port.shm == (char *)-1)
-    {
-        ee_printf("ERROR in parent shmat!\n");
-        return 0;
-    }
-    memcpy(&(res->crc), res->port.shm, 8);
-    shmdt(res->port.shm);
-    return 1;
-}
-#elif USE_SOCKET
-static int key_id = 0;
-ee_u8
-core_start_parallel(core_results *res)
-{
-    int bound, buffer_length = 8;
-    res->port.sa.sin_family      = AF_INET;
-    res->port.sa.sin_addr.s_addr = htonl(0x7F000001);
-    res->port.sa.sin_port        = htons(7654 + key_id);
-    key_id++;
-    res->port.pid = fork();
-    if (res->port.pid == 0)
-    { /* benchmark child */
-        iterate(res);
-        res->port.sock = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);
-        if (-1 == res->port.sock) /* if socket failed to initialize, exit */
-        {
-            ee_printf("Error Creating Socket");
-        }
-        else
-        {
-            int bytes_sent = sendto(res->port.sock,
-                                    &(res->crc),
-                                    buffer_length,
-                                    0,
-                                    (struct sockaddr *)&(res->port.sa),
-                                    sizeof(struct sockaddr_in));
-            if (bytes_sent < 0)
-                ee_printf("Error sending packet: %s\n", strerror(errno));
-            close(res->port.sock); /* close the socket */
-        }
-        exit(0);
-    }
-    /* parent process, open the socket */
-    res->port.sock = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);
-    bound          = bind(res->port.sock,
-                 (struct sockaddr *)&(res->port.sa),
-                 sizeof(struct sockaddr));
-    if (bound < 0)
-        ee_printf("bind(): %s\n", strerror(errno));
-    return 1;
-}
-ee_u8
-core_stop_parallel(core_results *res)
-{
-    int status;
-    int fromlen = sizeof(struct sockaddr);
-    int recsize = recvfrom(res->port.sock,
-                           &(res->crc),
-                           8,
-                           0,
-                           (struct sockaddr *)&(res->port.sa),
-                           &fromlen);
-    if (recsize < 0)
-    {
-        ee_printf("Error in receive: %s\n", strerror(errno));
-        return 0;
-    }
-    pid_t wpid = waitpid(res->port.pid, &status, WUNTRACED);
-    if (wpid != res->port.pid)
-    {
-        ee_printf("ERROR waiting for child.\n");
-        if (errno == ECHILD)
-            ee_printf("errno=No such child %d\n", res->port.pid);
-        if (errno == EINTR)
-            ee_printf("errno=Interrupted\n");
-        return 0;
-    }
-    return 1;
-}
-#else /* no standard multicore implementation */
-#error \
-    "Please implement multicore functionality in core_portme.c to use multiple contexts."
-#endif /* multithread implementations */
-#endif
diff --git a/sw/app/coremark/cygwin/core_portme.h b/sw/app/coremark/cygwin/core_portme.h
deleted file mode 100644
index 09c2a86..0000000
--- a/sw/app/coremark/cygwin/core_portme.h
+++ /dev/null
@@ -1,312 +0,0 @@
-/*
-Copyright 2018 Embedded Microprocessor Benchmark Consortium (EEMBC)
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-
-Original Author: Shay Gal-on
-*/
-
-/* Topic: Description
-        This file contains configuration constants required to execute on
-   different platforms
-*/
-#ifndef CORE_PORTME_H
-#define CORE_PORTME_H
-/************************/
-/* Data types and settings */
-/************************/
-/* Configuration: HAS_FLOAT
-        Define to 1 if the platform supports floating point.
-*/
-#ifndef HAS_FLOAT
-#define HAS_FLOAT 1
-#endif
-/* Configuration: HAS_TIME_H
-        Define to 1 if platform has the time.h header file,
-        and implementation of functions thereof.
-*/
-#ifndef HAS_TIME_H
-#define HAS_TIME_H 1
-#endif
-/* Configuration: USE_CLOCK
-        Define to 1 if platform has the time.h header file,
-        and implementation of functions thereof.
-*/
-#ifndef USE_CLOCK
-#define USE_CLOCK 0
-#endif
-/* Configuration: HAS_STDIO
-        Define to 1 if the platform has stdio.h.
-*/
-#ifndef HAS_STDIO
-#define HAS_STDIO 1
-#endif
-/* Configuration: HAS_PRINTF
-        Define to 1 if the platform has stdio.h and implements the printf
-   function.
-*/
-#ifndef HAS_PRINTF
-#define HAS_PRINTF 1
-#endif
-
-/* Configuration: CORE_TICKS
-        Define type of return from the timing functions.
- */
-#if defined(_MSC_VER)
-#include <windows.h>
-typedef size_t CORE_TICKS;
-#elif HAS_TIME_H
-#include <time.h>
-typedef clock_t CORE_TICKS;
-#else
-#error \
-    "Please define type of CORE_TICKS and implement start_time, end_time get_time and time_in_secs functions!"
-#endif
-
-/* Definitions: COMPILER_VERSION, COMPILER_FLAGS, MEM_LOCATION
-        Initialize these strings per platform
-*/
-#ifndef COMPILER_VERSION
-#ifdef __GNUC__
-#define COMPILER_VERSION "GCC"__VERSION__
-#else
-#define COMPILER_VERSION "Please put compiler version here (e.g. gcc 4.1)"
-#endif
-#endif
-#ifndef COMPILER_FLAGS
-#define COMPILER_FLAGS \
-    FLAGS_STR /* "Please put compiler flags here (e.g. -o3)" */
-#endif
-#ifndef MEM_LOCATION
-#define MEM_LOCATION                                                         \
-    "Please put data memory location here\n\t\t\t(e.g. code in flash, data " \
-    "on heap etc)"
-#define MEM_LOCATION_UNSPEC 1
-#endif
-
-/* Data Types:
-        To avoid compiler issues, define the data types that need ot be used for
-   8b, 16b and 32b in <core_portme.h>.
-
-        *Imprtant*:
-        ee_ptr_int needs to be the data type used to hold pointers, otherwise
-   coremark may fail!!!
-*/
-typedef signed short   ee_s16;
-typedef unsigned short ee_u16;
-typedef signed int     ee_s32;
-typedef double         ee_f32;
-typedef unsigned char  ee_u8;
-typedef unsigned int   ee_u32;
-typedef ee_u32         ee_ptr_int;
-typedef size_t         ee_size_t;
-/* align_mem:
-        This macro is used to align an offset to point to a 32b value. It is
-   used in the Matrix algorithm to initialize the input memory blocks.
-*/
-#define align_mem(x) (void *)(4 + (((ee_ptr_int)(x)-1) & ~3))
-
-/* Configuration: SEED_METHOD
-        Defines method to get seed values that cannot be computed at compile
-   time.
-
-        Valid values:
-        SEED_ARG - from command line.
-        SEED_FUNC - from a system function.
-        SEED_VOLATILE - from volatile variables.
-*/
-#ifndef SEED_METHOD
-#define SEED_METHOD SEED_ARG
-#endif
-
-/* Configuration: MEM_METHOD
-        Defines method to get a block of memry.
-
-        Valid values:
-        MEM_MALLOC - for platforms that implement malloc and have malloc.h.
-        MEM_STATIC - to use a static memory array.
-        MEM_STACK - to allocate the data block on the stack (NYI).
-*/
-#ifndef MEM_METHOD
-#define MEM_METHOD MEM_MALLOC
-#endif
-
-/* Configuration: MULTITHREAD
-        Define for parallel execution
-
-        Valid values:
-        1 - only one context (default).
-        N>1 - will execute N copies in parallel.
-
-        Note:
-        If this flag is defined to more then 1, an implementation for launching
-   parallel contexts must be defined.
-
-        Two sample implementations are provided. Use <USE_PTHREAD> or <USE_FORK>
-   to enable them.
-
-        It is valid to have a different implementation of <core_start_parallel>
-   and <core_end_parallel> in <core_portme.c>, to fit a particular architecture.
-*/
-#ifndef MULTITHREAD
-#define MULTITHREAD 1
-#endif
-
-/* Configuration: USE_PTHREAD
-        Sample implementation for launching parallel contexts
-        This implementation uses pthread_thread_create and pthread_join.
-
-        Valid values:
-        0 - Do not use pthreads API.
-        1 - Use pthreads API
-
-        Note:
-        This flag only matters if MULTITHREAD has been defined to a value
-   greater then 1.
-*/
-#ifndef USE_PTHREAD
-#define USE_PTHREAD 0
-#endif
-
-/* Configuration: USE_FORK
-        Sample implementation for launching parallel contexts
-        This implementation uses fork, waitpid, shmget,shmat and shmdt.
-
-        Valid values:
-        0 - Do not use fork API.
-        1 - Use fork API
-
-        Note:
-        This flag only matters if MULTITHREAD has been defined to a value
-   greater then 1.
-*/
-#ifndef USE_FORK
-#define USE_FORK 0
-#endif
-
-/* Configuration: USE_SOCKET
-        Sample implementation for launching parallel contexts
-        This implementation uses fork, socket, sendto and recvfrom
-
-        Valid values:
-        0 - Do not use fork and sockets API.
-        1 - Use fork and sockets API
-
-        Note:
-        This flag only matters if MULTITHREAD has been defined to a value
-   greater then 1.
-*/
-#ifndef USE_SOCKET
-#define USE_SOCKET 0
-#endif
-
-/* Configuration: MAIN_HAS_NOARGC
-        Needed if platform does not support getting arguments to main.
-
-        Valid values:
-        0 - argc/argv to main is supported
-        1 - argc/argv to main is not supported
-*/
-#ifndef MAIN_HAS_NOARGC
-#define MAIN_HAS_NOARGC 0
-#endif
-
-/* Configuration: MAIN_HAS_NORETURN
-        Needed if platform does not support returning a value from main.
-
-        Valid values:
-        0 - main returns an int, and return value will be 0.
-        1 - platform does not support returning a value from main
-*/
-#ifndef MAIN_HAS_NORETURN
-#define MAIN_HAS_NORETURN 0
-#endif
-
-/* Variable: default_num_contexts
-        Number of contexts to spawn in multicore context.
-        Override this global value to change number of contexts used.
-
-        Note:
-        This value may not be set higher then the <MULTITHREAD> define.
-
-        To experiment, you can set the <MULTITHREAD> define to the highest value
-   expected, and use argc/argv in the <portable_init> to set this value from the
-   command line.
-*/
-extern ee_u32 default_num_contexts;
-
-#if (MULTITHREAD > 1)
-#if USE_PTHREAD
-#include <pthread.h>
-#define PARALLEL_METHOD "PThreads"
-#elif USE_FORK
-#include <unistd.h>
-#include <errno.h>
-#include <sys/wait.h>
-#include <sys/shm.h>
-#include <string.h> /* for memcpy */
-#define PARALLEL_METHOD "Fork"
-#elif USE_SOCKET
-#include <sys/types.h>
-#include <sys/socket.h>
-#include <netinet/in.h>
-#include <arpa/inet.h>
-#include <sys/wait.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-#include <errno.h>
-#define PARALLEL_METHOD "Sockets"
-#else
-#define PARALLEL_METHOD "Proprietary"
-#error \
-    "Please implement multicore functionality in core_portme.c to use multiple contexts."
-#endif /* Method for multithreading */
-#endif /* MULTITHREAD > 1 */
-
-typedef struct CORE_PORTABLE_S
-{
-#if (MULTITHREAD > 1)
-#if USE_PTHREAD
-    pthread_t thread;
-#elif USE_FORK
-    pid_t pid;
-    int   shmid;
-    void *shm;
-#elif USE_SOCKET
-    pid_t              pid;
-    int                sock;
-    struct sockaddr_in sa;
-#endif /* Method for multithreading */
-#endif /* MULTITHREAD>1 */
-    ee_u8 portable_id;
-} core_portable;
-
-/* target specific init/fini */
-void portable_init(core_portable *p, int *argc, char *argv[]);
-void portable_fini(core_portable *p);
-
-#if (SEED_METHOD == SEED_VOLATILE)
-#if (VALIDATION_RUN || PERFORMANCE_RUN || PROFILE_RUN)
-#define RUN_TYPE_FLAG 1
-#else
-#if (TOTAL_DATA_SIZE == 1200)
-#define PROFILE_RUN 1
-#else
-#define PERFORMANCE_RUN 1
-#endif
-#endif
-#endif /* SEED_METHOD==SEED_VOLATILE */
-
-#endif /* CORE_PORTME_H */
diff --git a/sw/app/coremark/cygwin/core_portme.mak b/sw/app/coremark/cygwin/core_portme.mak
deleted file mode 100755
index 721ba2e..0000000
--- a/sw/app/coremark/cygwin/core_portme.mak
+++ /dev/null
@@ -1,141 +0,0 @@
-# Copyright 2018 Embedded Microprocessor Benchmark Consortium (EEMBC)
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#    http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-# 
-# Original Author: Shay Gal-on
-
-#File: core_portme.mak
-
-# Flag: OUTFLAG
-#	Use this flag to define how to to get an executable (e.g -o)
-OUTFLAG= -o
-# Flag: CC
-#	Use this flag to define compiler to use
-CC = gcc
-# Flag: CFLAGS
-#	Use this flag to define compiler options. Note, you can add compiler options from the command line using XCFLAGS="other flags"
-PORT_CFLAGS = -O2
-FLAGS_STR = "$(PORT_CFLAGS) $(XCFLAGS) $(XLFLAGS) $(LFLAGS_END)"
-CFLAGS = $(PORT_CFLAGS) -I$(PORT_DIR) -I. -DFLAGS_STR=\"$(FLAGS_STR)\"
-#Flag: LFLAGS_END
-#	Define any libraries needed for linking or other flags that should come at the end of the link line (e.g. linker scripts). 
-#	Note: On certain platforms, the default clock_gettime implementation is supported but requires linking of librt.
-LFLAGS_END = 
-# Flag: PORT_SRCS
-# Port specific source files can be added here
-PORT_SRCS = $(PORT_DIR)/core_portme.c
-# Flag: LOAD
-#	Define this flag if you need to load to a target, as in a cross compile environment.
-
-# Flag: RUN
-#	Define this flag if running does not consist of simple invocation of the binary.
-#	In a cross compile environment, you need to define this.
-
-#For flashing and using a tera term macro, you could use
-#LOAD = flash ADDR 
-#RUN =  ttpmacro coremark.ttl
-
-#For copying to target and executing via SSH connection, you could use
-#LOAD = scp $(OUTFILE)  user@target:~
-#RUN = ssh user@target -c  
-
-#For native compilation and execution
-LOAD = echo Loading done
-RUN = 
-
-OEXT = .o
-EXE = .exe
-
-# Flag: SEPARATE_COMPILE
-# Define if you need to separate compilation from link stage. 
-# In this case, you also need to define below how to create an object file, and how to link.
-ifdef SEPARATE_COMPILE
-
-LD		= gcc
-OBJOUT 	= -o
-LFLAGS 	=
-OFLAG 	= -o
-COUT 	= -c
-# Flag: PORT_OBJS
-# Port specific object files can be added here
-PORT_OBJS = $(PORT_DIR)/core_portme$(OEXT)
-PORT_CLEAN = *$(OEXT)
-
-$(OPATH)%$(OEXT) : %.c
-	$(CC) $(CFLAGS) $(XCFLAGS) $(COUT) $< $(OBJOUT) $@
-	
-endif
-
-# Target: port_prebuild
-# Generate any files that are needed before actual build starts.
-# E.g. generate profile guidance files. Sample PGO generation for gcc enabled with PGO=1
-#  - First, check if PGO was defined on the command line, if so, need to add -fprofile-use to compile line.
-#  - Second, if PGO reference has not yet been generated, add a step to the prebuild that will build a profile-generate version and run it.
-#  Note - Using REBUILD=1 
-#
-# Use make PGO=1 to invoke this sample processing.
-
-ifdef PGO
- ifeq (,$(findstring $(PGO),gen))
-  PGO_STAGE=build_pgo_gcc
-  CFLAGS+=-fprofile-use
- endif
- PORT_CLEAN+=*.gcda *.gcno gmon.out
-endif
-
-.PHONY: port_prebuild
-port_prebuild: $(PGO_STAGE)
-
-.PHONY: build_pgo_gcc
-build_pgo_gcc:
-	$(MAKE) PGO=gen XCFLAGS="$(XCFLAGS) -fprofile-generate -DTOTAL_DATA_SIZE=1200" ITERATIONS=10 gen_pgo_data REBUILD=1
-	
-# Target: port_postbuild
-# Generate any files that are needed after actual build end.
-# E.g. change format to srec, bin, zip in order to be able to load into flash
-.PHONY: port_postbuild
-port_postbuild:
-
-# Target: port_postrun
-# 	Do platform specific after run stuff. 
-#	E.g. reset the board, backup the logfiles etc.
-.PHONY: port_postrun
-port_postrun:
-
-# Target: port_prerun
-# 	Do platform specific after run stuff. 
-#	E.g. reset the board, backup the logfiles etc.
-.PHONY: port_prerun
-port_prerun:
-
-# Target: port_postload
-# 	Do platform specific after load stuff. 
-#	E.g. reset the reset power to the flash eraser
-.PHONY: port_postload
-port_postload:
-
-# Target: port_preload
-# 	Do platform specific before load stuff. 
-#	E.g. reset the reset power to the flash eraser
-.PHONY: port_preload
-port_preload:
-
-
-# FLAG: OPATH
-# Path to the output folder. Default - current folder.
-OPATH = ./
-MKDIR = mkdir -p
-
-# FLAG: PERL
-# Define perl executable to calculate the geomean if running separate.
-PERL=perl
diff --git a/sw/app/coremark/freebsd/core_portme.c b/sw/app/coremark/freebsd/core_portme.c
deleted file mode 100644
index f5a7f5b..0000000
--- a/sw/app/coremark/freebsd/core_portme.c
+++ /dev/null
@@ -1,419 +0,0 @@
-/*
-Copyright 2018 Embedded Microprocessor Benchmark Consortium (EEMBC)
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-
-Original Author: Shay Gal-on
-*/
-
-#include <stdio.h>
-#include <stdlib.h>
-#include "coremark.h"
-#if CALLGRIND_RUN
-#include <valgrind/callgrind.h>
-#endif
-
-#if (MEM_METHOD == MEM_MALLOC)
-/* Function: portable_malloc
-        Provide malloc() functionality in a platform specific way.
-*/
-void *
-portable_malloc(size_t size)
-{
-    return malloc(size);
-}
-/* Function: portable_free
-        Provide free() functionality in a platform specific way.
-*/
-void
-portable_free(void *p)
-{
-    free(p);
-}
-#else
-void *
-portable_malloc(size_t size)
-{
-    return NULL;
-}
-void
-portable_free(void *p)
-{
-    p = NULL;
-}
-#endif
-
-#if (SEED_METHOD == SEED_VOLATILE)
-#if VALIDATION_RUN
-volatile ee_s32 seed1_volatile = 0x3415;
-volatile ee_s32 seed2_volatile = 0x3415;
-volatile ee_s32 seed3_volatile = 0x66;
-#endif
-#if PERFORMANCE_RUN
-volatile ee_s32 seed1_volatile = 0x0;
-volatile ee_s32 seed2_volatile = 0x0;
-volatile ee_s32 seed3_volatile = 0x66;
-#endif
-#if PROFILE_RUN
-volatile ee_s32 seed1_volatile = 0x8;
-volatile ee_s32 seed2_volatile = 0x8;
-volatile ee_s32 seed3_volatile = 0x8;
-#endif
-volatile ee_s32 seed4_volatile = ITERATIONS;
-volatile ee_s32 seed5_volatile = 0;
-#endif
-/* Porting: Timing functions
-        How to capture time and convert to seconds must be ported to whatever is
-   supported by the platform. e.g. Read value from on board RTC, read value from
-   cpu clock cycles performance counter etc. Sample implementation for standard
-   time.h and windows.h definitions included.
-*/
-/* Define: TIMER_RES_DIVIDER
-        Divider to trade off timer resolution and total time that can be
-   measured.
-
-        Use lower values to increase resolution, but make sure that overflow
-   does not occur. If there are issues with the return value overflowing,
-   increase this value.
-        */
-#if USE_CLOCK
-#define NSECS_PER_SEC              CLOCKS_PER_SEC
-#define EE_TIMER_TICKER_RATE       1000
-#define CORETIMETYPE               clock_t
-#define GETMYTIME(_t)              (*_t = clock())
-#define MYTIMEDIFF(fin, ini)       ((fin) - (ini))
-#define TIMER_RES_DIVIDER          1
-#define SAMPLE_TIME_IMPLEMENTATION 1
-#elif defined(_MSC_VER)
-#define NSECS_PER_SEC        10000000
-#define EE_TIMER_TICKER_RATE 1000
-#define CORETIMETYPE         FILETIME
-#define GETMYTIME(_t)        GetSystemTimeAsFileTime(_t)
-#define MYTIMEDIFF(fin, ini) \
-    (((*(__int64 *)&fin) - (*(__int64 *)&ini)) / TIMER_RES_DIVIDER)
-/* setting to millisces resolution by default with MSDEV */
-#ifndef TIMER_RES_DIVIDER
-#define TIMER_RES_DIVIDER 1000
-#endif
-#define SAMPLE_TIME_IMPLEMENTATION 1
-#elif HAS_TIME_H
-#define NSECS_PER_SEC        1000000000
-#define EE_TIMER_TICKER_RATE 1000
-#define CORETIMETYPE         struct timespec
-#define GETMYTIME(_t)        clock_gettime(CLOCK_REALTIME, _t)
-#define MYTIMEDIFF(fin, ini)                                         \
-    ((fin.tv_sec - ini.tv_sec) * (NSECS_PER_SEC / TIMER_RES_DIVIDER) \
-     + (fin.tv_nsec - ini.tv_nsec) / TIMER_RES_DIVIDER)
-/* setting to 1/1000 of a second resolution by default with linux */
-#ifndef TIMER_RES_DIVIDER
-#define TIMER_RES_DIVIDER 1000000
-#endif
-#define SAMPLE_TIME_IMPLEMENTATION 1
-#else
-#define SAMPLE_TIME_IMPLEMENTATION 0
-#endif
-#define EE_TICKS_PER_SEC (NSECS_PER_SEC / TIMER_RES_DIVIDER)
-
-#if SAMPLE_TIME_IMPLEMENTATION
-/** Define Host specific (POSIX), or target specific global time variables. */
-static CORETIMETYPE start_time_val, stop_time_val;
-
-/* Function: start_time
-        This function will be called right before starting the timed portion of
-   the benchmark.
-
-        Implementation may be capturing a system timer (as implemented in the
-   example code) or zeroing some system parameters - e.g. setting the cpu clocks
-   cycles to 0.
-*/
-void
-start_time(void)
-{
-    GETMYTIME(&start_time_val);
-#if CALLGRIND_RUN
-    CALLGRIND_START_INSTRUMENTATION
-#endif
-#if MICA
-    asm volatile("int3"); /*1 */
-#endif
-}
-/* Function: stop_time
-        This function will be called right after ending the timed portion of the
-   benchmark.
-
-        Implementation may be capturing a system timer (as implemented in the
-   example code) or other system parameters - e.g. reading the current value of
-   cpu cycles counter.
-*/
-void
-stop_time(void)
-{
-#if CALLGRIND_RUN
-    CALLGRIND_STOP_INSTRUMENTATION
-#endif
-#if MICA
-    asm volatile("int3"); /*1 */
-#endif
-    GETMYTIME(&stop_time_val);
-}
-/* Function: get_time
-        Return an abstract "ticks" number that signifies time on the system.
-
-        Actual value returned may be cpu cycles, milliseconds or any other
-   value, as long as it can be converted to seconds by <time_in_secs>. This
-   methodology is taken to accomodate any hardware or simulated platform. The
-   sample implementation returns millisecs by default, and the resolution is
-   controlled by <TIMER_RES_DIVIDER>
-*/
-CORE_TICKS
-get_time(void)
-{
-    CORE_TICKS elapsed
-        = (CORE_TICKS)(MYTIMEDIFF(stop_time_val, start_time_val));
-    return elapsed;
-}
-/* Function: time_in_secs
-        Convert the value returned by get_time to seconds.
-
-        The <secs_ret> type is used to accomodate systems with no support for
-   floating point. Default implementation implemented by the EE_TICKS_PER_SEC
-   macro above.
-*/
-secs_ret
-time_in_secs(CORE_TICKS ticks)
-{
-    secs_ret retval = ((secs_ret)ticks) / (secs_ret)EE_TICKS_PER_SEC;
-    return retval;
-}
-#else
-#error "Please implement timing functionality in core_portme.c"
-#endif /* SAMPLE_TIME_IMPLEMENTATION */
-
-ee_u32 default_num_contexts = MULTITHREAD;
-
-/* Function: portable_init
-        Target specific initialization code
-        Test for some common mistakes.
-*/
-void
-portable_init(core_portable *p, int *argc, char *argv[])
-{
-#if PRINT_ARGS
-    int i;
-    for (i = 0; i < *argc; i++)
-    {
-        ee_printf("Arg[%d]=%s\n", i, argv[i]);
-    }
-#endif
-    if (sizeof(ee_ptr_int) != sizeof(ee_u8 *))
-    {
-        ee_printf(
-            "ERROR! Please define ee_ptr_int to a type that holds a "
-            "pointer!\n");
-    }
-    if (sizeof(ee_u32) != 4)
-    {
-        ee_printf("ERROR! Please define ee_u32 to a 32b unsigned type!\n");
-    }
-#if (MAIN_HAS_NOARGC && (SEED_METHOD == SEED_ARG))
-    ee_printf(
-        "ERROR! Main has no argc, but SEED_METHOD defined to SEED_ARG!\n");
-#endif
-
-#if (MULTITHREAD > 1) && (SEED_METHOD == SEED_ARG)
-    int nargs = *argc, i;
-    if ((nargs > 1) && (*argv[1] == 'M'))
-    {
-        default_num_contexts = parseval(argv[1] + 1);
-        if (default_num_contexts > MULTITHREAD)
-            default_num_contexts = MULTITHREAD;
-        /* Shift args since first arg is directed to the portable part and not
-         * to coremark main */
-        --nargs;
-        for (i = 1; i < nargs; i++)
-            argv[i] = argv[i + 1];
-        *argc = nargs;
-    }
-#endif /* sample of potential platform specific init via command line, reset \
-          the number of contexts being used if first argument is M<n>*/
-    p->portable_id = 1;
-}
-/* Function: portable_fini
-        Target specific final code
-*/
-void
-portable_fini(core_portable *p)
-{
-    p->portable_id = 0;
-}
-
-#if (MULTITHREAD > 1)
-
-/* Function: core_start_parallel
-        Start benchmarking in a parallel context.
-
-        Three implementations are provided, one using pthreads, one using fork
-   and shared mem, and one using fork and sockets. Other implementations using
-   MCAPI or other standards can easily be devised.
-*/
-/* Function: core_stop_parallel
-        Stop a parallel context execution of coremark, and gather the results.
-
-        Three implementations are provided, one using pthreads, one using fork
-   and shared mem, and one using fork and sockets. Other implementations using
-   MCAPI or other standards can easily be devised.
-*/
-#if USE_PTHREAD
-ee_u8
-core_start_parallel(core_results *res)
-{
-    return (ee_u8)pthread_create(
-        &(res->port.thread), NULL, iterate, (void *)res);
-}
-ee_u8
-core_stop_parallel(core_results *res)
-{
-    void *retval;
-    return (ee_u8)pthread_join(res->port.thread, &retval);
-}
-#elif USE_FORK
-static int key_id = 0;
-ee_u8
-core_start_parallel(core_results *res)
-{
-    key_t key = 4321 + key_id;
-    key_id++;
-    res->port.pid   = fork();
-    res->port.shmid = shmget(key, 8, IPC_CREAT | 0666);
-    if (res->port.shmid < 0)
-    {
-        ee_printf("ERROR in shmget!\n");
-    }
-    if (res->port.pid == 0)
-    {
-        iterate(res);
-        res->port.shm = shmat(res->port.shmid, NULL, 0);
-        /* copy the validation values to the shared memory area  and quit*/
-        if (res->port.shm == (char *)-1)
-        {
-            ee_printf("ERROR in child shmat!\n");
-        }
-        else
-        {
-            memcpy(res->port.shm, &(res->crc), 8);
-            shmdt(res->port.shm);
-        }
-        exit(0);
-    }
-    return 1;
-}
-ee_u8
-core_stop_parallel(core_results *res)
-{
-    int   status;
-    pid_t wpid = waitpid(res->port.pid, &status, WUNTRACED);
-    if (wpid != res->port.pid)
-    {
-        ee_printf("ERROR waiting for child.\n");
-        if (errno == ECHILD)
-            ee_printf("errno=No such child %d\n", res->port.pid);
-        if (errno == EINTR)
-            ee_printf("errno=Interrupted\n");
-        return 0;
-    }
-    /* after process is done, get the values from the shared memory area */
-    res->port.shm = shmat(res->port.shmid, NULL, 0);
-    if (res->port.shm == (char *)-1)
-    {
-        ee_printf("ERROR in parent shmat!\n");
-        return 0;
-    }
-    memcpy(&(res->crc), res->port.shm, 8);
-    shmdt(res->port.shm);
-    return 1;
-}
-#elif USE_SOCKET
-static int key_id = 0;
-ee_u8
-core_start_parallel(core_results *res)
-{
-    int bound, buffer_length = 8;
-    res->port.sa.sin_family      = AF_INET;
-    res->port.sa.sin_addr.s_addr = htonl(0x7F000001);
-    res->port.sa.sin_port        = htons(7654 + key_id);
-    key_id++;
-    res->port.pid = fork();
-    if (res->port.pid == 0)
-    { /* benchmark child */
-        iterate(res);
-        res->port.sock = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);
-        if (-1 == res->port.sock) /* if socket failed to initialize, exit */
-        {
-            ee_printf("Error Creating Socket");
-        }
-        else
-        {
-            int bytes_sent = sendto(res->port.sock,
-                                    &(res->crc),
-                                    buffer_length,
-                                    0,
-                                    (struct sockaddr *)&(res->port.sa),
-                                    sizeof(struct sockaddr_in));
-            if (bytes_sent < 0)
-                ee_printf("Error sending packet: %s\n", strerror(errno));
-            close(res->port.sock); /* close the socket */
-        }
-        exit(0);
-    }
-    /* parent process, open the socket */
-    res->port.sock = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);
-    bound          = bind(res->port.sock,
-                 (struct sockaddr *)&(res->port.sa),
-                 sizeof(struct sockaddr));
-    if (bound < 0)
-        ee_printf("bind(): %s\n", strerror(errno));
-    return 1;
-}
-ee_u8
-core_stop_parallel(core_results *res)
-{
-    int status;
-    int fromlen = sizeof(struct sockaddr);
-    int recsize = recvfrom(res->port.sock,
-                           &(res->crc),
-                           8,
-                           0,
-                           (struct sockaddr *)&(res->port.sa),
-                           &fromlen);
-    if (recsize < 0)
-    {
-        ee_printf("Error in receive: %s\n", strerror(errno));
-        return 0;
-    }
-    pid_t wpid = waitpid(res->port.pid, &status, WUNTRACED);
-    if (wpid != res->port.pid)
-    {
-        ee_printf("ERROR waiting for child.\n");
-        if (errno == ECHILD)
-            ee_printf("errno=No such child %d\n", res->port.pid);
-        if (errno == EINTR)
-            ee_printf("errno=Interrupted\n");
-        return 0;
-    }
-    return 1;
-}
-#else /* no standard multicore implementation */
-#error \
-    "Please implement multicore functionality in core_portme.c to use multiple contexts."
-#endif /* multithread implementations */
-#endif
diff --git a/sw/app/coremark/freebsd/core_portme.h b/sw/app/coremark/freebsd/core_portme.h
deleted file mode 100644
index 2614d32..0000000
--- a/sw/app/coremark/freebsd/core_portme.h
+++ /dev/null
@@ -1,309 +0,0 @@
-/*
-Copyright 2018 Embedded Microprocessor Benchmark Consortium (EEMBC)
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-
-Original Author: Shay Gal-on
-*/
-
-/* Topic: Description
-        This file contains configuration constants required to execute on
-   different platforms
-*/
-#ifndef CORE_PORTME_H
-#define CORE_PORTME_H
-/************************/
-/* Data types and settings */
-/************************/
-/* Configuration: HAS_FLOAT
-        Define to 1 if the platform supports floating point.
-*/
-#ifndef HAS_FLOAT
-#define HAS_FLOAT 1
-#endif
-/* Configuration: HAS_TIME_H
-        Define to 1 if platform has the time.h header file,
-        and implementation of functions thereof.
-*/
-#ifndef HAS_TIME_H
-#define HAS_TIME_H 1
-#endif
-/* Configuration: USE_CLOCK
-        Define to 1 if platform has the time.h header file,
-        and implementation of functions thereof.
-*/
-#ifndef USE_CLOCK
-#define USE_CLOCK 0
-#endif
-/* Configuration: HAS_STDIO
-        Define to 1 if the platform has stdio.h.
-*/
-#ifndef HAS_STDIO
-#define HAS_STDIO 1
-#endif
-/* Configuration: HAS_PRINTF
-        Define to 1 if the platform has stdio.h and implements the printf
-   function.
-*/
-#ifndef HAS_PRINTF
-#define HAS_PRINTF 1
-#endif
-
-/* Configuration: CORE_TICKS
-        Define type of return from the timing functions.
- */
-#if defined(_MSC_VER)
-#include <windows.h>
-typedef size_t CORE_TICKS;
-#elif HAS_TIME_H
-#include <time.h>
-typedef clock_t CORE_TICKS;
-#else
-#error \
-    "Please define type of CORE_TICKS and implement start_time, end_time get_time and time_in_secs functions!"
-#endif
-
-/* Definitions: COMPILER_VERSION, COMPILER_FLAGS, MEM_LOCATION
-        Initialize these strings per platform
-*/
-#ifndef COMPILER_VERSION
-#ifdef __GNUC__
-#define COMPILER_VERSION "GCC"__VERSION__
-#else
-#define COMPILER_VERSION "Please put compiler version here (e.g. gcc 4.1)"
-#endif
-#endif
-#ifndef COMPILER_FLAGS
-#define COMPILER_FLAGS \
-    FLAGS_STR /* "Please put compiler flags here (e.g. -o3)" */
-#endif
-#ifndef MEM_LOCATION
-#define MEM_LOCATION                                                         \
-    "Please put data memory location here\n\t\t\t(e.g. code in flash, data " \
-    "on heap etc)"
-#define MEM_LOCATION_UNSPEC 1
-#endif
-
-/* Data Types:
-        To avoid compiler issues, define the data types that need ot be used for
-   8b, 16b and 32b in <core_portme.h>.
-
-        *Imprtant*:
-        ee_ptr_int needs to be the data type used to hold pointers, otherwise
-   coremark may fail!!!
-*/
-typedef signed short   ee_s16;
-typedef unsigned short ee_u16;
-typedef signed int     ee_s32;
-typedef double         ee_f32;
-typedef unsigned char  ee_u8;
-typedef unsigned int   ee_u32;
-typedef unsigned long  ee_ptr_int;
-typedef size_t         ee_size_t;
-/* align an offset to point to a 32b value */
-#define align_mem(x) (void *)(4 + (((ee_ptr_int)(x)-1) & ~3))
-
-/* Configuration: SEED_METHOD
-        Defines method to get seed values that cannot be computed at compile
-   time.
-
-        Valid values:
-        SEED_ARG - from command line.
-        SEED_FUNC - from a system function.
-        SEED_VOLATILE - from volatile variables.
-*/
-#ifndef SEED_METHOD
-#define SEED_METHOD SEED_ARG
-#endif
-
-/* Configuration: MEM_METHOD
-        Defines method to get a block of memry.
-
-        Valid values:
-        MEM_MALLOC - for platforms that implement malloc and have malloc.h.
-        MEM_STATIC - to use a static memory array.
-        MEM_STACK - to allocate the data block on the stack (NYI).
-*/
-#ifndef MEM_METHOD
-#define MEM_METHOD MEM_MALLOC
-#endif
-
-/* Configuration: MULTITHREAD
-        Define for parallel execution
-
-        Valid values:
-        1 - only one context (default).
-        N>1 - will execute N copies in parallel.
-
-        Note:
-        If this flag is defined to more then 1, an implementation for launching
-   parallel contexts must be defined.
-
-        Two sample implementations are provided. Use <USE_PTHREAD> or <USE_FORK>
-   to enable them.
-
-        It is valid to have a different implementation of <core_start_parallel>
-   and <core_end_parallel> in <core_portme.c>, to fit a particular architecture.
-*/
-#ifndef MULTITHREAD
-#define MULTITHREAD 1
-#endif
-
-/* Configuration: USE_PTHREAD
-        Sample implementation for launching parallel contexts
-        This implementation uses pthread_thread_create and pthread_join.
-
-        Valid values:
-        0 - Do not use pthreads API.
-        1 - Use pthreads API
-
-        Note:
-        This flag only matters if MULTITHREAD has been defined to a value
-   greater then 1.
-*/
-#ifndef USE_PTHREAD
-#define USE_PTHREAD 0
-#endif
-
-/* Configuration: USE_FORK
-        Sample implementation for launching parallel contexts
-        This implementation uses fork, waitpid, shmget,shmat and shmdt.
-
-        Valid values:
-        0 - Do not use fork API.
-        1 - Use fork API
-
-        Note:
-        This flag only matters if MULTITHREAD has been defined to a value
-   greater then 1.
-*/
-#ifndef USE_FORK
-#define USE_FORK 0
-#endif
-
-/* Configuration: USE_SOCKET
-        Sample implementation for launching parallel contexts
-        This implementation uses fork, socket, sendto and recvfrom
-
-        Valid values:
-        0 - Do not use fork and sockets API.
-        1 - Use fork and sockets API
-
-        Note:
-        This flag only matters if MULTITHREAD has been defined to a value
-   greater then 1.
-*/
-#ifndef USE_SOCKET
-#define USE_SOCKET 0
-#endif
-
-/* Configuration: MAIN_HAS_NOARGC
-        Needed if platform does not support getting arguments to main.
-
-        Valid values:
-        0 - argc/argv to main is supported
-        1 - argc/argv to main is not supported
-*/
-#ifndef MAIN_HAS_NOARGC
-#define MAIN_HAS_NOARGC 0
-#endif
-
-/* Configuration: MAIN_HAS_NORETURN
-        Needed if platform does not support returning a value from main.
-
-        Valid values:
-        0 - main returns an int, and return value will be 0.
-        1 - platform does not support returning a value from main
-*/
-#ifndef MAIN_HAS_NORETURN
-#define MAIN_HAS_NORETURN 0
-#endif
-
-/* Variable: default_num_contexts
-        Number of contexts to spawn in multicore context.
-        Override this global value to change number of contexts used.
-
-        Note:
-        This value may not be set higher then the <MULTITHREAD> define.
-
-        To experiment, you can set the <MULTITHREAD> define to the highest value
-   expected, and use argc/argv in the <portable_init> to set this value from the
-   command line.
-*/
-extern ee_u32 default_num_contexts;
-
-#if (MULTITHREAD > 1)
-#if USE_PTHREAD
-#include <pthread.h>
-#define PARALLEL_METHOD "PThreads"
-#elif USE_FORK
-#include <unistd.h>
-#include <errno.h>
-#include <sys/wait.h>
-#include <sys/shm.h>
-#include <string.h> /* for memcpy */
-#define PARALLEL_METHOD "Fork"
-#elif USE_SOCKET
-#include <sys/types.h>
-#include <sys/socket.h>
-#include <netinet/in.h>
-#include <arpa/inet.h>
-#include <sys/wait.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-#include <errno.h>
-#define PARALLEL_METHOD "Sockets"
-#else
-#define PARALLEL_METHOD "Proprietary"
-#error \
-    "Please implement multicore functionality in core_portme.c to use multiple contexts."
-#endif /* Method for multithreading */
-#endif /* MULTITHREAD > 1 */
-
-typedef struct CORE_PORTABLE_S
-{
-#if (MULTITHREAD > 1)
-#if USE_PTHREAD
-    pthread_t thread;
-#elif USE_FORK
-    pid_t pid;
-    int   shmid;
-    void *shm;
-#elif USE_SOCKET
-    pid_t              pid;
-    int                sock;
-    struct sockaddr_in sa;
-#endif /* Method for multithreading */
-#endif /* MULTITHREAD>1 */
-    ee_u8 portable_id;
-} core_portable;
-
-/* target specific init/fini */
-void portable_init(core_portable *p, int *argc, char *argv[]);
-void portable_fini(core_portable *p);
-
-#if (SEED_METHOD == SEED_VOLATILE)
-#if (VALIDATION_RUN || PERFORMANCE_RUN || PROFILE_RUN)
-#define RUN_TYPE_FLAG 1
-#else
-#if (TOTAL_DATA_SIZE == 1200)
-#define PROFILE_RUN 1
-#else
-#define PERFORMANCE_RUN 1
-#endif
-#endif
-#endif /* SEED_METHOD==SEED_VOLATILE */
-
-#endif /* CORE_PORTME_H */
diff --git a/sw/app/coremark/freebsd/core_portme.mak b/sw/app/coremark/freebsd/core_portme.mak
deleted file mode 100755
index fbb8f08..0000000
--- a/sw/app/coremark/freebsd/core_portme.mak
+++ /dev/null
@@ -1,140 +0,0 @@
-# Copyright 2018 Embedded Microprocessor Benchmark Consortium (EEMBC)
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#    http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-# 
-# Original Author: Shay Gal-on
-
-#File: core_portme.mak
-
-# Flag: OUTFLAG
-#	Use this flag to define how to to get an executable (e.g -o)
-OUTFLAG= -o
-# Flag: CC
-#	Use this flag to define compiler to use
-CC?= cc
-# Flag: CFLAGS
-#	Use this flag to define compiler options. Note, you can add compiler options from the command line using XCFLAGS="other flags"
-PORT_CFLAGS = -O2
-FLAGS_STR = "$(PORT_CFLAGS) $(XCFLAGS) $(XLFLAGS) $(LFLAGS_END)"
-CFLAGS = $(PORT_CFLAGS) -I$(PORT_DIR) -I. -DFLAGS_STR=\"$(FLAGS_STR)\"
-#Flag: LFLAGS_END
-#	Define any libraries needed for linking or other flags that should come at the end of the link line (e.g. linker scripts). 
-#	Note: On certain platforms, the default clock_gettime implementation is supported but requires linking of librt.
-LFLAGS_END += -lrt
-# Flag: PORT_SRCS
-# Port specific source files can be added here
-PORT_SRCS = $(PORT_DIR)/core_portme.c
-# Flag: LOAD
-#	Define this flag if you need to load to a target, as in a cross compile environment.
-
-# Flag: RUN
-#	Define this flag if running does not consist of simple invocation of the binary.
-#	In a cross compile environment, you need to define this.
-
-#For flashing and using a tera term macro, you could use
-#LOAD = flash ADDR 
-#RUN =  ttpmacro coremark.ttl
-
-#For copying to target and executing via SSH connection, you could use
-#LOAD = scp $(OUTFILE)  user@target:~
-#RUN = ssh user@target -c  
-
-#For native compilation and execution
-LOAD = echo Loading done
-RUN = 
-
-OEXT = .o
-EXE = .exe
-
-# Flag: SEPARATE_COMPILE
-# Define if you need to separate compilation from link stage. 
-# In this case, you also need to define below how to create an object file, and how to link.
-ifdef SEPARATE_COMPILE
-
-LD		= gcc
-OBJOUT 	= -o
-LFLAGS 	=
-OFLAG 	= -o
-COUT 	= -c
-# Flag: PORT_OBJS
-# Port specific object files can be added here
-PORT_OBJS = $(PORT_DIR)/core_portme$(OEXT)
-PORT_CLEAN = *$(OEXT)
-
-$(OPATH)%$(OEXT) : %.c
-	$(CC) $(CFLAGS) $(XCFLAGS) $(COUT) $< $(OBJOUT) $@
-	
-endif
-
-# Target: port_prebuild
-# Generate any files that are needed before actual build starts.
-# E.g. generate profile guidance files. Sample PGO generation for gcc enabled with PGO=1
-#  - First, check if PGO was defined on the command line, if so, need to add -fprofile-use to compile line.
-#  - Second, if PGO reference has not yet been generated, add a step to the prebuild that will build a profile-generate version and run it.
-#  Note - Using REBUILD=1 
-#
-# Use make PGO=1 to invoke this sample processing.
-
-ifdef PGO
- ifeq (,$(findstring $(PGO),gen))
-  PGO_STAGE=build_pgo_gcc
-  CFLAGS+=-fprofile-use
- endif
- PORT_CLEAN+=*.gcda *.gcno gmon.out
-endif
-
-.PHONY: port_prebuild
-port_prebuild: $(PGO_STAGE)
-
-.PHONY: build_pgo_gcc
-build_pgo_gcc:
-	$(MAKE) PGO=gen XCFLAGS="$(XCFLAGS) -fprofile-generate -DTOTAL_DATA_SIZE=1200" ITERATIONS=10 gen_pgo_data REBUILD=1
-	
-# Target: port_postbuild
-# Generate any files that are needed after actual build end.
-# E.g. change format to srec, bin, zip in order to be able to load into flash
-.PHONY: port_postbuild
-port_postbuild:
-
-# Target: port_postrun
-# 	Do platform specific after run stuff. 
-#	E.g. reset the board, backup the logfiles etc.
-.PHONY: port_postrun
-port_postrun:
-
-# Target: port_prerun
-# 	Do platform specific after run stuff. 
-#	E.g. reset the board, backup the logfiles etc.
-.PHONY: port_prerun
-port_prerun:
-
-# Target: port_postload
-# 	Do platform specific after load stuff. 
-#	E.g. reset the reset power to the flash eraser
-.PHONY: port_postload
-port_postload:
-
-# Target: port_preload
-# 	Do platform specific before load stuff. 
-#	E.g. reset the reset power to the flash eraser
-.PHONY: port_preload
-port_preload:
-
-# FLAG: OPATH
-# Path to the output folder. Default - current folder.
-OPATH = ./
-MKDIR = mkdir -p
-
-# FLAG: PERL
-# Define perl executable to calculate the geomean if running separate.
-PERL=/usr/bin/perl
diff --git a/sw/app/coremark/linux/core_portme.c b/sw/app/coremark/linux/core_portme.c
deleted file mode 100644
index 40a0d67..0000000
--- a/sw/app/coremark/linux/core_portme.c
+++ /dev/null
@@ -1,422 +0,0 @@
-/*
-Copyright 2018 Embedded Microprocessor Benchmark Consortium (EEMBC)
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-
-Original Author: Shay Gal-on
-*/
-
-#include <stdio.h>
-#include <stdlib.h>
-#include "coremark.h"
-#if CALLGRIND_RUN
-#include <valgrind/callgrind.h>
-#endif
-
-#if (MEM_METHOD == MEM_MALLOC)
-#include <malloc.h>
-/* Function: portable_malloc
-        Provide malloc() functionality in a platform specific way.
-*/
-void *
-portable_malloc(size_t size)
-{
-    return malloc(size);
-}
-/* Function: portable_free
-        Provide free() functionality in a platform specific way.
-*/
-void
-portable_free(void *p)
-{
-    free(p);
-}
-#else
-void *
-portable_malloc(size_t size)
-{
-    return NULL;
-}
-void
-portable_free(void *p)
-{
-    p = NULL;
-}
-#endif
-
-#if (SEED_METHOD == SEED_VOLATILE)
-#if VALIDATION_RUN
-volatile ee_s32 seed1_volatile = 0x3415;
-volatile ee_s32 seed2_volatile = 0x3415;
-volatile ee_s32 seed3_volatile = 0x66;
-#endif
-#if PERFORMANCE_RUN
-volatile ee_s32 seed1_volatile = 0x0;
-volatile ee_s32 seed2_volatile = 0x0;
-volatile ee_s32 seed3_volatile = 0x66;
-#endif
-#if PROFILE_RUN
-volatile ee_s32 seed1_volatile = 0x8;
-volatile ee_s32 seed2_volatile = 0x8;
-volatile ee_s32 seed3_volatile = 0x8;
-#endif
-volatile ee_s32 seed4_volatile = ITERATIONS;
-volatile ee_s32 seed5_volatile = 0;
-#endif
-/* Porting: Timing functions
-        How to capture time and convert to seconds must be ported to whatever is
-   supported by the platform. e.g. Read value from on board RTC, read value from
-   cpu clock cycles performance counter etc. Sample implementation for standard
-   time.h and windows.h definitions included.
-*/
-/* Define: TIMER_RES_DIVIDER
-        Divider to trade off timer resolution and total time that can be
-   measured.
-
-        Use lower values to increase resolution, but make sure that overflow
-   does not occur. If there are issues with the return value overflowing,
-   increase this value.
-        */
-#if USE_CLOCK
-#define NSECS_PER_SEC              CLOCKS_PER_SEC
-#define EE_TIMER_TICKER_RATE       1000
-#define CORETIMETYPE               clock_t
-#define GETMYTIME(_t)              (*_t = clock())
-#define MYTIMEDIFF(fin, ini)       ((fin) - (ini))
-#define TIMER_RES_DIVIDER          1
-#define SAMPLE_TIME_IMPLEMENTATION 1
-#elif defined(_MSC_VER)
-#define NSECS_PER_SEC        10000000
-#define EE_TIMER_TICKER_RATE 1000
-#define CORETIMETYPE         FILETIME
-#define GETMYTIME(_t)        GetSystemTimeAsFileTime(_t)
-#define MYTIMEDIFF(fin, ini) \
-    (((*(__int64 *)&fin) - (*(__int64 *)&ini)) / TIMER_RES_DIVIDER)
-/* setting to millisces resolution by default with MSDEV */
-#ifndef TIMER_RES_DIVIDER
-#define TIMER_RES_DIVIDER 1000
-#endif
-#define SAMPLE_TIME_IMPLEMENTATION 1
-#elif HAS_TIME_H
-#define NSECS_PER_SEC        1000000000
-#define EE_TIMER_TICKER_RATE 1000
-#define CORETIMETYPE         struct timespec
-#define GETMYTIME(_t)        clock_gettime(CLOCK_REALTIME, _t)
-#define MYTIMEDIFF(fin, ini)                                         \
-    ((fin.tv_sec - ini.tv_sec) * (NSECS_PER_SEC / TIMER_RES_DIVIDER) \
-     + (fin.tv_nsec - ini.tv_nsec) / TIMER_RES_DIVIDER)
-/* setting to 1/1000 of a second resolution by default with linux */
-#ifndef TIMER_RES_DIVIDER
-#define TIMER_RES_DIVIDER 1000000
-#endif
-#define SAMPLE_TIME_IMPLEMENTATION 1
-#else
-#define SAMPLE_TIME_IMPLEMENTATION 0
-#endif
-#define EE_TICKS_PER_SEC (NSECS_PER_SEC / TIMER_RES_DIVIDER)
-
-#if SAMPLE_TIME_IMPLEMENTATION
-/** Define Host specific (POSIX), or target specific global time variables. */
-static CORETIMETYPE start_time_val, stop_time_val;
-
-/* Function: start_time
-        This function will be called right before starting the timed portion of
-   the benchmark.
-
-        Implementation may be capturing a system timer (as implemented in the
-   example code) or zeroing some system parameters - e.g. setting the cpu clocks
-   cycles to 0.
-*/
-void
-start_time(void)
-{
-    GETMYTIME(&start_time_val);
-#if CALLGRIND_RUN
-    CALLGRIND_START_INSTRUMENTATION
-#endif
-#if MICA
-    asm volatile("int3"); /*1 */
-#endif
-}
-/* Function: stop_time
-        This function will be called right after ending the timed portion of the
-   benchmark.
-
-        Implementation may be capturing a system timer (as implemented in the
-   example code) or other system parameters - e.g. reading the current value of
-   cpu cycles counter.
-*/
-void
-stop_time(void)
-{
-#if CALLGRIND_RUN
-    CALLGRIND_STOP_INSTRUMENTATION
-#endif
-#if MICA
-    asm volatile("int3"); /*1 */
-#endif
-    GETMYTIME(&stop_time_val);
-}
-/* Function: get_time
-        Return an abstract "ticks" number that signifies time on the system.
-
-        Actual value returned may be cpu cycles, milliseconds or any other
-   value, as long as it can be converted to seconds by <time_in_secs>. This
-   methodology is taken to accomodate any hardware or simulated platform. The
-   sample implementation returns millisecs by default, and the resolution is
-   controlled by <TIMER_RES_DIVIDER>
-*/
-CORE_TICKS
-get_time(void)
-{
-    CORE_TICKS elapsed
-        = (CORE_TICKS)(MYTIMEDIFF(stop_time_val, start_time_val));
-    return elapsed;
-}
-/* Function: time_in_secs
-        Convert the value returned by get_time to seconds.
-
-        The <secs_ret> type is used to accomodate systems with no support for
-   floating point. Default implementation implemented by the EE_TICKS_PER_SEC
-   macro above.
-*/
-secs_ret
-time_in_secs(CORE_TICKS ticks)
-{
-    secs_ret retval = ((secs_ret)ticks) / (secs_ret)EE_TICKS_PER_SEC;
-    return retval;
-}
-#else
-#error "Please implement timing functionality in core_portme.c"
-#endif /* SAMPLE_TIME_IMPLEMENTATION */
-
-ee_u32 default_num_contexts = MULTITHREAD;
-
-/* Function: portable_init
-        Target specific initialization code
-        Test for some common mistakes.
-*/
-void
-portable_init(core_portable *p, int *argc, char *argv[])
-{
-#if PRINT_ARGS
-    int i;
-    for (i = 0; i < *argc; i++)
-    {
-        ee_printf("Arg[%d]=%s\n", i, argv[i]);
-    }
-#endif
-    if (sizeof(ee_ptr_int) != sizeof(ee_u8 *))
-    {
-        ee_printf(
-            "ERROR! Please define ee_ptr_int to a type that holds a "
-            "pointer!\n");
-    }
-    if (sizeof(ee_u32) != 4)
-    {
-        ee_printf("ERROR! Please define ee_u32 to a 32b unsigned type!\n");
-    }
-#if (MAIN_HAS_NOARGC && (SEED_METHOD == SEED_ARG))
-    ee_printf(
-        "ERROR! Main has no argc, but SEED_METHOD defined to SEED_ARG!\n");
-#endif
-
-#if (MULTITHREAD > 1) && (SEED_METHOD == SEED_ARG)
-    {
-        int nargs = *argc, i;
-        if ((nargs > 1) && (*argv[1] == 'M'))
-        {
-            default_num_contexts = parseval(argv[1] + 1);
-            if (default_num_contexts > MULTITHREAD)
-                default_num_contexts = MULTITHREAD;
-            /* Shift args since first arg is directed to the portable part and
-             * not to coremark main */
-            --nargs;
-            for (i = 1; i < nargs; i++)
-                argv[i] = argv[i + 1];
-            *argc = nargs;
-        }
-    }
-#endif /* sample of potential platform specific init via command line, reset \
-          the number of contexts being used if first argument is M<n>*/
-    p->portable_id = 1;
-}
-/* Function: portable_fini
-        Target specific final code
-*/
-void
-portable_fini(core_portable *p)
-{
-    p->portable_id = 0;
-}
-
-#if (MULTITHREAD > 1)
-
-/* Function: core_start_parallel
-        Start benchmarking in a parallel context.
-
-        Three implementations are provided, one using pthreads, one using fork
-   and shared mem, and one using fork and sockets. Other implementations using
-   MCAPI or other standards can easily be devised.
-*/
-/* Function: core_stop_parallel
-        Stop a parallel context execution of coremark, and gather the results.
-
-        Three implementations are provided, one using pthreads, one using fork
-   and shared mem, and one using fork and sockets. Other implementations using
-   MCAPI or other standards can easily be devised.
-*/
-#if USE_PTHREAD
-ee_u8
-core_start_parallel(core_results *res)
-{
-    return (ee_u8)pthread_create(
-        &(res->port.thread), NULL, iterate, (void *)res);
-}
-ee_u8
-core_stop_parallel(core_results *res)
-{
-    void *retval;
-    return (ee_u8)pthread_join(res->port.thread, &retval);
-}
-#elif USE_FORK
-static int key_id = 0;
-ee_u8
-core_start_parallel(core_results *res)
-{
-    key_t key = 4321 + key_id;
-    key_id++;
-    res->port.pid   = fork();
-    res->port.shmid = shmget(key, 8, IPC_CREAT | 0666);
-    if (res->port.shmid < 0)
-    {
-        ee_printf("ERROR in shmget!\n");
-    }
-    if (res->port.pid == 0)
-    {
-        iterate(res);
-        res->port.shm = shmat(res->port.shmid, NULL, 0);
-        /* copy the validation values to the shared memory area  and quit*/
-        if (res->port.shm == (char *)-1)
-        {
-            ee_printf("ERROR in child shmat!\n");
-        }
-        else
-        {
-            memcpy(res->port.shm, &(res->crc), 8);
-            shmdt(res->port.shm);
-        }
-        exit(0);
-    }
-    return 1;
-}
-ee_u8
-core_stop_parallel(core_results *res)
-{
-    int   status;
-    pid_t wpid = waitpid(res->port.pid, &status, WUNTRACED);
-    if (wpid != res->port.pid)
-    {
-        ee_printf("ERROR waiting for child.\n");
-        if (errno == ECHILD)
-            ee_printf("errno=No such child %d\n", res->port.pid);
-        if (errno == EINTR)
-            ee_printf("errno=Interrupted\n");
-        return 0;
-    }
-    /* after process is done, get the values from the shared memory area */
-    res->port.shm = shmat(res->port.shmid, NULL, 0);
-    if (res->port.shm == (char *)-1)
-    {
-        ee_printf("ERROR in parent shmat!\n");
-        return 0;
-    }
-    memcpy(&(res->crc), res->port.shm, 8);
-    shmdt(res->port.shm);
-    return 1;
-}
-#elif USE_SOCKET
-static int key_id = 0;
-ee_u8
-core_start_parallel(core_results *res)
-{
-    int bound, buffer_length = 8;
-    res->port.sa.sin_family      = AF_INET;
-    res->port.sa.sin_addr.s_addr = htonl(0x7F000001);
-    res->port.sa.sin_port        = htons(7654 + key_id);
-    key_id++;
-    res->port.pid = fork();
-    if (res->port.pid == 0)
-    { /* benchmark child */
-        iterate(res);
-        res->port.sock = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);
-        if (-1 == res->port.sock) /* if socket failed to initialize, exit */
-        {
-            ee_printf("Error Creating Socket");
-        }
-        else
-        {
-            int bytes_sent = sendto(res->port.sock,
-                                    &(res->crc),
-                                    buffer_length,
-                                    0,
-                                    (struct sockaddr *)&(res->port.sa),
-                                    sizeof(struct sockaddr_in));
-            if (bytes_sent < 0)
-                ee_printf("Error sending packet: %s\n", strerror(errno));
-            close(res->port.sock); /* close the socket */
-        }
-        exit(0);
-    }
-    /* parent process, open the socket */
-    res->port.sock = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);
-    bound          = bind(res->port.sock,
-                 (struct sockaddr *)&(res->port.sa),
-                 sizeof(struct sockaddr));
-    if (bound < 0)
-        ee_printf("bind(): %s\n", strerror(errno));
-    return 1;
-}
-ee_u8
-core_stop_parallel(core_results *res)
-{
-    int status;
-    int fromlen = sizeof(struct sockaddr);
-    int recsize = recvfrom(res->port.sock,
-                           &(res->crc),
-                           8,
-                           0,
-                           (struct sockaddr *)&(res->port.sa),
-                           &fromlen);
-    if (recsize < 0)
-    {
-        ee_printf("Error in receive: %s\n", strerror(errno));
-        return 0;
-    }
-    pid_t wpid = waitpid(res->port.pid, &status, WUNTRACED);
-    if (wpid != res->port.pid)
-    {
-        ee_printf("ERROR waiting for child.\n");
-        if (errno == ECHILD)
-            ee_printf("errno=No such child %d\n", res->port.pid);
-        if (errno == EINTR)
-            ee_printf("errno=Interrupted\n");
-        return 0;
-    }
-    return 1;
-}
-#else /* no standard multicore implementation */
-#error \
-    "Please implement multicore functionality in core_portme.c to use multiple contexts."
-#endif /* multithread implementations */
-#endif
diff --git a/sw/app/coremark/linux/core_portme.h b/sw/app/coremark/linux/core_portme.h
deleted file mode 100644
index 64dd82a..0000000
--- a/sw/app/coremark/linux/core_portme.h
+++ /dev/null
@@ -1,308 +0,0 @@
-/*
-Copyright 2018 Embedded Microprocessor Benchmark Consortium (EEMBC)
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-
-Original Author: Shay Gal-on
-*/
-
-#ifndef CORE_PORTME_H
-#define CORE_PORTME_H
-/************************/
-/* Data types and settings */
-/************************/
-/* Configuration: HAS_FLOAT
-        Define to 1 if the platform supports floating point.
-*/
-#ifndef HAS_FLOAT
-#define HAS_FLOAT 1
-#endif
-/* Configuration: HAS_TIME_H
-        Define to 1 if platform has the time.h header file,
-        and implementation of functions thereof.
-*/
-#ifndef HAS_TIME_H
-#define HAS_TIME_H 1
-#endif
-/* Configuration: USE_CLOCK
-        Define to 1 if platform has the time.h header file,
-        and implementation of functions thereof.
-*/
-#ifndef USE_CLOCK
-#define USE_CLOCK 0
-#endif
-/* Configuration: HAS_STDIO
-        Define to 1 if the platform has stdio.h.
-*/
-#ifndef HAS_STDIO
-#define HAS_STDIO 1
-#endif
-/* Configuration: HAS_PRINTF
-        Define to 1 if the platform has stdio.h and implements the printf
-   function.
-*/
-#ifndef HAS_PRINTF
-#define HAS_PRINTF 1
-#endif
-
-/* Configuration: CORE_TICKS
-        Define type of return from the timing functions.
- */
-#if defined(_MSC_VER)
-#include <windows.h>
-typedef size_t CORE_TICKS;
-#elif HAS_TIME_H
-#include <time.h>
-typedef clock_t CORE_TICKS;
-#else
-#error \
-    "Please define type of CORE_TICKS and implement start_time, end_time get_time and time_in_secs functions!"
-#endif
-
-/* Definitions: COMPILER_VERSION, COMPILER_FLAGS, MEM_LOCATION
-        Initialize these strings per platform
-*/
-#ifndef COMPILER_VERSION
-#ifdef __GNUC__
-#define COMPILER_VERSION "GCC"__VERSION__
-#else
-#define COMPILER_VERSION "Please put compiler version here (e.g. gcc 4.1)"
-#endif
-#endif
-#ifndef COMPILER_FLAGS
-#define COMPILER_FLAGS \
-    FLAGS_STR /* "Please put compiler flags here (e.g. -o3)" */
-#endif
-#ifndef MEM_LOCATION
-#define MEM_LOCATION                                                         \
-    "Please put data memory location here\n\t\t\t(e.g. code in flash, data " \
-    "on heap etc)"
-#define MEM_LOCATION_UNSPEC 1
-#endif
-
-/* Data Types:
-        To avoid compiler issues, define the data types that need ot be used for
-   8b, 16b and 32b in <core_portme.h>.
-
-        *Imprtant*:
-        ee_ptr_int needs to be the data type used to hold pointers, otherwise
-   coremark may fail!!!
-*/
-typedef signed short   ee_s16;
-typedef unsigned short ee_u16;
-typedef signed int     ee_s32;
-typedef double         ee_f32;
-typedef unsigned char  ee_u8;
-typedef unsigned int   ee_u32;
-typedef ee_u32         ee_ptr_int;
-typedef size_t         ee_size_t;
-/* align_mem:
-        This macro is used to align an offset to point to a 32b value. It is
-   used in the Matrix algorithm to initialize the input memory blocks.
-*/
-#define align_mem(x) (void *)(4 + (((ee_ptr_int)(x)-1) & ~3))
-
-/* Configuration: SEED_METHOD
-        Defines method to get seed values that cannot be computed at compile
-   time.
-
-        Valid values:
-        SEED_ARG - from command line.
-        SEED_FUNC - from a system function.
-        SEED_VOLATILE - from volatile variables.
-*/
-#ifndef SEED_METHOD
-#define SEED_METHOD SEED_ARG
-#endif
-
-/* Configuration: MEM_METHOD
-        Defines method to get a block of memry.
-
-        Valid values:
-        MEM_MALLOC - for platforms that implement malloc and have malloc.h.
-        MEM_STATIC - to use a static memory array.
-        MEM_STACK - to allocate the data block on the stack (NYI).
-*/
-#ifndef MEM_METHOD
-#define MEM_METHOD MEM_MALLOC
-#endif
-
-/* Configuration: MULTITHREAD
-        Define for parallel execution
-
-        Valid values:
-        1 - only one context (default).
-        N>1 - will execute N copies in parallel.
-
-        Note:
-        If this flag is defined to more then 1, an implementation for launching
-   parallel contexts must be defined.
-
-        Two sample implementations are provided. Use <USE_PTHREAD> or <USE_FORK>
-   to enable them.
-
-        It is valid to have a different implementation of <core_start_parallel>
-   and <core_end_parallel> in <core_portme.c>, to fit a particular architecture.
-*/
-#ifndef MULTITHREAD
-#define MULTITHREAD 1
-#endif
-
-/* Configuration: USE_PTHREAD
-        Sample implementation for launching parallel contexts
-        This implementation uses pthread_thread_create and pthread_join.
-
-        Valid values:
-        0 - Do not use pthreads API.
-        1 - Use pthreads API
-
-        Note:
-        This flag only matters if MULTITHREAD has been defined to a value
-   greater then 1.
-*/
-#ifndef USE_PTHREAD
-#define USE_PTHREAD 0
-#endif
-
-/* Configuration: USE_FORK
-        Sample implementation for launching parallel contexts
-        This implementation uses fork, waitpid, shmget,shmat and shmdt.
-
-        Valid values:
-        0 - Do not use fork API.
-        1 - Use fork API
-
-        Note:
-        This flag only matters if MULTITHREAD has been defined to a value
-   greater then 1.
-*/
-#ifndef USE_FORK
-#define USE_FORK 0
-#endif
-
-/* Configuration: USE_SOCKET
-        Sample implementation for launching parallel contexts
-        This implementation uses fork, socket, sendto and recvfrom
-
-        Valid values:
-        0 - Do not use fork and sockets API.
-        1 - Use fork and sockets API
-
-        Note:
-        This flag only matters if MULTITHREAD has been defined to a value
-   greater then 1.
-*/
-#ifndef USE_SOCKET
-#define USE_SOCKET 0
-#endif
-
-/* Configuration: MAIN_HAS_NOARGC
-        Needed if platform does not support getting arguments to main.
-
-        Valid values:
-        0 - argc/argv to main is supported
-        1 - argc/argv to main is not supported
-*/
-#ifndef MAIN_HAS_NOARGC
-#define MAIN_HAS_NOARGC 0
-#endif
-
-/* Configuration: MAIN_HAS_NORETURN
-        Needed if platform does not support returning a value from main.
-
-        Valid values:
-        0 - main returns an int, and return value will be 0.
-        1 - platform does not support returning a value from main
-*/
-#ifndef MAIN_HAS_NORETURN
-#define MAIN_HAS_NORETURN 0
-#endif
-
-/* Variable: default_num_contexts
-        Number of contexts to spawn in multicore context.
-        Override this global value to change number of contexts used.
-
-        Note:
-        This value may not be set higher then the <MULTITHREAD> define.
-
-        To experiment, you can set the <MULTITHREAD> define to the highest value
-   expected, and use argc/argv in the <portable_init> to set this value from the
-   command line.
-*/
-extern ee_u32 default_num_contexts;
-
-#if (MULTITHREAD > 1)
-#if USE_PTHREAD
-#include <pthread.h>
-#define PARALLEL_METHOD "PThreads"
-#elif USE_FORK
-#include <unistd.h>
-#include <errno.h>
-#include <sys/wait.h>
-#include <sys/shm.h>
-#include <string.h> /* for memcpy */
-#define PARALLEL_METHOD "Fork"
-#elif USE_SOCKET
-#include <sys/types.h>
-#include <sys/socket.h>
-#include <netinet/in.h>
-#include <arpa/inet.h>
-#include <sys/wait.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-#include <errno.h>
-#define PARALLEL_METHOD "Sockets"
-#else
-#define PARALLEL_METHOD "Proprietary"
-#error \
-    "Please implement multicore functionality in core_portme.c to use multiple contexts."
-#endif /* Method for multithreading */
-#endif /* MULTITHREAD > 1 */
-
-typedef struct CORE_PORTABLE_S
-{
-#if (MULTITHREAD > 1)
-#if USE_PTHREAD
-    pthread_t thread;
-#elif USE_FORK
-    pid_t pid;
-    int   shmid;
-    void *shm;
-#elif USE_SOCKET
-    pid_t              pid;
-    int                sock;
-    struct sockaddr_in sa;
-#endif /* Method for multithreading */
-#endif /* MULTITHREAD>1 */
-    ee_u8 portable_id;
-} core_portable;
-
-/* target specific init/fini */
-void portable_init(core_portable *p, int *argc, char *argv[]);
-void portable_fini(core_portable *p);
-
-#if (SEED_METHOD == SEED_VOLATILE)
-#if (VALIDATION_RUN || PERFORMANCE_RUN || PROFILE_RUN)
-#define RUN_TYPE_FLAG 1
-#else
-#if (TOTAL_DATA_SIZE == 1200)
-#define PROFILE_RUN 1
-#else
-#define PERFORMANCE_RUN 1
-#endif
-#endif
-#endif /* SEED_METHOD==SEED_VOLATILE */
-
-#endif /* CORE_PORTME_H */
diff --git a/sw/app/coremark/linux/core_portme.mak b/sw/app/coremark/linux/core_portme.mak
deleted file mode 100755
index 5cfabee..0000000
--- a/sw/app/coremark/linux/core_portme.mak
+++ /dev/null
@@ -1,140 +0,0 @@
-# Copyright 2018 Embedded Microprocessor Benchmark Consortium (EEMBC)
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#    http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-# 
-# Original Author: Shay Gal-on
-
-#File: core_portme.mak
-
-# Flag: OUTFLAG
-#	Use this flag to define how to to get an executable (e.g -o)
-OUTFLAG= -o
-# Flag: CC
-#	Use this flag to define compiler to use
-CC = gcc
-# Flag: CFLAGS
-#	Use this flag to define compiler options. Note, you can add compiler options from the command line using XCFLAGS="other flags"
-PORT_CFLAGS = -O2
-FLAGS_STR = "$(PORT_CFLAGS) $(XCFLAGS) $(XLFLAGS) $(LFLAGS_END)"
-CFLAGS = $(PORT_CFLAGS) -I$(PORT_DIR) -I. -DFLAGS_STR=\"$(FLAGS_STR)\"
-#Flag: LFLAGS_END
-#	Define any libraries needed for linking or other flags that should come at the end of the link line (e.g. linker scripts). 
-#	Note: On certain platforms, the default clock_gettime implementation is supported but requires linking of librt.
-LFLAGS_END += -lrt
-# Flag: PORT_SRCS
-# Port specific source files can be added here
-PORT_SRCS = $(PORT_DIR)/core_portme.c
-# Flag: LOAD
-#	Define this flag if you need to load to a target, as in a cross compile environment.
-
-# Flag: RUN
-#	Define this flag if running does not consist of simple invocation of the binary.
-#	In a cross compile environment, you need to define this.
-
-#For flashing and using a tera term macro, you could use
-#LOAD = flash ADDR 
-#RUN =  ttpmacro coremark.ttl
-
-#For copying to target and executing via SSH connection, you could use
-#LOAD = scp $(OUTFILE)  user@target:~
-#RUN = ssh user@target -c  
-
-#For native compilation and execution
-LOAD = echo Loading done
-RUN = 
-
-OEXT = .o
-EXE = .exe
-
-# Flag: SEPARATE_COMPILE
-# Define if you need to separate compilation from link stage. 
-# In this case, you also need to define below how to create an object file, and how to link.
-ifdef SEPARATE_COMPILE
-
-LD		= gcc
-OBJOUT 	= -o
-LFLAGS 	=
-OFLAG 	= -o
-COUT 	= -c
-# Flag: PORT_OBJS
-# Port specific object files can be added here
-PORT_OBJS = $(PORT_DIR)/core_portme$(OEXT)
-PORT_CLEAN = *$(OEXT)
-
-$(OPATH)%$(OEXT) : %.c
-	$(CC) $(CFLAGS) $(XCFLAGS) $(COUT) $< $(OBJOUT) $@
-	
-endif
-
-# Target: port_prebuild
-# Generate any files that are needed before actual build starts.
-# E.g. generate profile guidance files. Sample PGO generation for gcc enabled with PGO=1
-#  - First, check if PGO was defined on the command line, if so, need to add -fprofile-use to compile line.
-#  - Second, if PGO reference has not yet been generated, add a step to the prebuild that will build a profile-generate version and run it.
-#  Note - Using REBUILD=1 
-#
-# Use make PGO=1 to invoke this sample processing.
-
-ifdef PGO
- ifeq (,$(findstring $(PGO),gen))
-  PGO_STAGE=build_pgo_gcc
-  CFLAGS+=-fprofile-use
- endif
- PORT_CLEAN+=*.gcda *.gcno gmon.out
-endif
-
-.PHONY: port_prebuild
-port_prebuild: $(PGO_STAGE)
-
-.PHONY: build_pgo_gcc
-build_pgo_gcc:
-	$(MAKE) PGO=gen XCFLAGS="$(XCFLAGS) -fprofile-generate -DTOTAL_DATA_SIZE=1200" ITERATIONS=10 gen_pgo_data REBUILD=1
-	
-# Target: port_postbuild
-# Generate any files that are needed after actual build end.
-# E.g. change format to srec, bin, zip in order to be able to load into flash
-.PHONY: port_postbuild
-port_postbuild:
-
-# Target: port_postrun
-# 	Do platform specific after run stuff. 
-#	E.g. reset the board, backup the logfiles etc.
-.PHONY: port_postrun
-port_postrun:
-
-# Target: port_prerun
-# 	Do platform specific after run stuff. 
-#	E.g. reset the board, backup the logfiles etc.
-.PHONY: port_prerun
-port_prerun:
-
-# Target: port_postload
-# 	Do platform specific after load stuff. 
-#	E.g. reset the reset power to the flash eraser
-.PHONY: port_postload
-port_postload:
-
-# Target: port_preload
-# 	Do platform specific before load stuff. 
-#	E.g. reset the reset power to the flash eraser
-.PHONY: port_preload
-port_preload:
-
-# FLAG: OPATH
-# Path to the output folder. Default - current folder.
-OPATH = ./
-MKDIR = mkdir -p
-
-# FLAG: PERL
-# Define perl executable to calculate the geomean if running separate.
-PERL=/usr/bin/perl
diff --git a/sw/app/coremark/linux64/core_portme.c b/sw/app/coremark/linux64/core_portme.c
deleted file mode 100644
index 00b618c..0000000
--- a/sw/app/coremark/linux64/core_portme.c
+++ /dev/null
@@ -1,420 +0,0 @@
-/*
-Copyright 2018 Embedded Microprocessor Benchmark Consortium (EEMBC)
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-
-Original Author: Shay Gal-on
-*/
-
-#include <stdio.h>
-#include <stdlib.h>
-#include "coremark.h"
-#if CALLGRIND_RUN
-#include <valgrind/callgrind.h>
-#endif
-
-#if (MEM_METHOD == MEM_MALLOC)
-#include <malloc.h>
-/* Function: portable_malloc
-        Provide malloc() functionality in a platform specific way.
-*/
-void *
-portable_malloc(size_t size)
-{
-    return malloc(size);
-}
-/* Function: portable_free
-        Provide free() functionality in a platform specific way.
-*/
-void
-portable_free(void *p)
-{
-    free(p);
-}
-#else
-void *
-portable_malloc(size_t size)
-{
-    return NULL;
-}
-void
-portable_free(void *p)
-{
-    p = NULL;
-}
-#endif
-
-#if (SEED_METHOD == SEED_VOLATILE)
-#if VALIDATION_RUN
-volatile ee_s32 seed1_volatile = 0x3415;
-volatile ee_s32 seed2_volatile = 0x3415;
-volatile ee_s32 seed3_volatile = 0x66;
-#endif
-#if PERFORMANCE_RUN
-volatile ee_s32 seed1_volatile = 0x0;
-volatile ee_s32 seed2_volatile = 0x0;
-volatile ee_s32 seed3_volatile = 0x66;
-#endif
-#if PROFILE_RUN
-volatile ee_s32 seed1_volatile = 0x8;
-volatile ee_s32 seed2_volatile = 0x8;
-volatile ee_s32 seed3_volatile = 0x8;
-#endif
-volatile ee_s32 seed4_volatile = ITERATIONS;
-volatile ee_s32 seed5_volatile = 0;
-#endif
-/* Porting: Timing functions
-        How to capture time and convert to seconds must be ported to whatever is
-   supported by the platform. e.g. Read value from on board RTC, read value from
-   cpu clock cycles performance counter etc. Sample implementation for standard
-   time.h and windows.h definitions included.
-*/
-/* Define: TIMER_RES_DIVIDER
-        Divider to trade off timer resolution and total time that can be
-   measured.
-
-        Use lower values to increase resolution, but make sure that overflow
-   does not occur. If there are issues with the return value overflowing,
-   increase this value.
-        */
-#if USE_CLOCK
-#define NSECS_PER_SEC              CLOCKS_PER_SEC
-#define EE_TIMER_TICKER_RATE       1000
-#define CORETIMETYPE               clock_t
-#define GETMYTIME(_t)              (*_t = clock())
-#define MYTIMEDIFF(fin, ini)       ((fin) - (ini))
-#define TIMER_RES_DIVIDER          1
-#define SAMPLE_TIME_IMPLEMENTATION 1
-#elif defined(_MSC_VER)
-#define NSECS_PER_SEC        10000000
-#define EE_TIMER_TICKER_RATE 1000
-#define CORETIMETYPE         FILETIME
-#define GETMYTIME(_t)        GetSystemTimeAsFileTime(_t)
-#define MYTIMEDIFF(fin, ini) \
-    (((*(__int64 *)&fin) - (*(__int64 *)&ini)) / TIMER_RES_DIVIDER)
-/* setting to millisces resolution by default with MSDEV */
-#ifndef TIMER_RES_DIVIDER
-#define TIMER_RES_DIVIDER 1000
-#endif
-#define SAMPLE_TIME_IMPLEMENTATION 1
-#elif HAS_TIME_H
-#define NSECS_PER_SEC        1000000000
-#define EE_TIMER_TICKER_RATE 1000
-#define CORETIMETYPE         struct timespec
-#define GETMYTIME(_t)        clock_gettime(CLOCK_REALTIME, _t)
-#define MYTIMEDIFF(fin, ini)                                         \
-    ((fin.tv_sec - ini.tv_sec) * (NSECS_PER_SEC / TIMER_RES_DIVIDER) \
-     + (fin.tv_nsec - ini.tv_nsec) / TIMER_RES_DIVIDER)
-/* setting to 1/1000 of a second resolution by default with linux */
-#ifndef TIMER_RES_DIVIDER
-#define TIMER_RES_DIVIDER 1000000
-#endif
-#define SAMPLE_TIME_IMPLEMENTATION 1
-#else
-#define SAMPLE_TIME_IMPLEMENTATION 0
-#endif
-#define EE_TICKS_PER_SEC (NSECS_PER_SEC / TIMER_RES_DIVIDER)
-
-#if SAMPLE_TIME_IMPLEMENTATION
-/** Define Host specific (POSIX), or target specific global time variables. */
-static CORETIMETYPE start_time_val, stop_time_val;
-
-/* Function: start_time
-        This function will be called right before starting the timed portion of
-   the benchmark.
-
-        Implementation may be capturing a system timer (as implemented in the
-   example code) or zeroing some system parameters - e.g. setting the cpu clocks
-   cycles to 0.
-*/
-void
-start_time(void)
-{
-    GETMYTIME(&start_time_val);
-#if CALLGRIND_RUN
-    CALLGRIND_START_INSTRUMENTATION
-#endif
-#if MICA
-    asm volatile("int3"); /*1 */
-#endif
-}
-/* Function: stop_time
-        This function will be called right after ending the timed portion of the
-   benchmark.
-
-        Implementation may be capturing a system timer (as implemented in the
-   example code) or other system parameters - e.g. reading the current value of
-   cpu cycles counter.
-*/
-void
-stop_time(void)
-{
-#if CALLGRIND_RUN
-    CALLGRIND_STOP_INSTRUMENTATION
-#endif
-#if MICA
-    asm volatile("int3"); /*1 */
-#endif
-    GETMYTIME(&stop_time_val);
-}
-/* Function: get_time
-        Return an abstract "ticks" number that signifies time on the system.
-
-        Actual value returned may be cpu cycles, milliseconds or any other
-   value, as long as it can be converted to seconds by <time_in_secs>. This
-   methodology is taken to accomodate any hardware or simulated platform. The
-   sample implementation returns millisecs by default, and the resolution is
-   controlled by <TIMER_RES_DIVIDER>
-*/
-CORE_TICKS
-get_time(void)
-{
-    CORE_TICKS elapsed
-        = (CORE_TICKS)(MYTIMEDIFF(stop_time_val, start_time_val));
-    return elapsed;
-}
-/* Function: time_in_secs
-        Convert the value returned by get_time to seconds.
-
-        The <secs_ret> type is used to accomodate systems with no support for
-   floating point. Default implementation implemented by the EE_TICKS_PER_SEC
-   macro above.
-*/
-secs_ret
-time_in_secs(CORE_TICKS ticks)
-{
-    secs_ret retval = ((secs_ret)ticks) / (secs_ret)EE_TICKS_PER_SEC;
-    return retval;
-}
-#else
-#error "Please implement timing functionality in core_portme.c"
-#endif /* SAMPLE_TIME_IMPLEMENTATION */
-
-ee_u32 default_num_contexts = MULTITHREAD;
-
-/* Function: portable_init
-        Target specific initialization code
-        Test for some common mistakes.
-*/
-void
-portable_init(core_portable *p, int *argc, char *argv[])
-{
-#if PRINT_ARGS
-    int i;
-    for (i = 0; i < *argc; i++)
-    {
-        ee_printf("Arg[%d]=%s\n", i, argv[i]);
-    }
-#endif
-    if (sizeof(ee_ptr_int) != sizeof(ee_u8 *))
-    {
-        ee_printf(
-            "ERROR! Please define ee_ptr_int to a type that holds a "
-            "pointer!\n");
-    }
-    if (sizeof(ee_u32) != 4)
-    {
-        ee_printf("ERROR! Please define ee_u32 to a 32b unsigned type!\n");
-    }
-#if (MAIN_HAS_NOARGC && (SEED_METHOD == SEED_ARG))
-    ee_printf(
-        "ERROR! Main has no argc, but SEED_METHOD defined to SEED_ARG!\n");
-#endif
-
-#if (MULTITHREAD > 1) && (SEED_METHOD == SEED_ARG)
-    int nargs = *argc, i;
-    if ((nargs > 1) && (*argv[1] == 'M'))
-    {
-        default_num_contexts = parseval(argv[1] + 1);
-        if (default_num_contexts > MULTITHREAD)
-            default_num_contexts = MULTITHREAD;
-        /* Shift args since first arg is directed to the portable part and not
-         * to coremark main */
-        --nargs;
-        for (i = 1; i < nargs; i++)
-            argv[i] = argv[i + 1];
-        *argc = nargs;
-    }
-#endif /* sample of potential platform specific init via command line, reset \
-          the number of contexts being used if first argument is M<n>*/
-    p->portable_id = 1;
-}
-/* Function: portable_fini
-        Target specific final code
-*/
-void
-portable_fini(core_portable *p)
-{
-    p->portable_id = 0;
-}
-
-#if (MULTITHREAD > 1)
-
-/* Function: core_start_parallel
-        Start benchmarking in a parallel context.
-
-        Three implementations are provided, one using pthreads, one using fork
-   and shared mem, and one using fork and sockets. Other implementations using
-   MCAPI or other standards can easily be devised.
-*/
-/* Function: core_stop_parallel
-        Stop a parallel context execution of coremark, and gather the results.
-
-        Three implementations are provided, one using pthreads, one using fork
-   and shared mem, and one using fork and sockets. Other implementations using
-   MCAPI or other standards can easily be devised.
-*/
-#if USE_PTHREAD
-ee_u8
-core_start_parallel(core_results *res)
-{
-    return (ee_u8)pthread_create(
-        &(res->port.thread), NULL, iterate, (void *)res);
-}
-ee_u8
-core_stop_parallel(core_results *res)
-{
-    void *retval;
-    return (ee_u8)pthread_join(res->port.thread, &retval);
-}
-#elif USE_FORK
-static int key_id = 0;
-ee_u8
-core_start_parallel(core_results *res)
-{
-    key_t key = 4321 + key_id;
-    key_id++;
-    res->port.pid   = fork();
-    res->port.shmid = shmget(key, 8, IPC_CREAT | 0666);
-    if (res->port.shmid < 0)
-    {
-        ee_printf("ERROR in shmget!\n");
-    }
-    if (res->port.pid == 0)
-    {
-        iterate(res);
-        res->port.shm = shmat(res->port.shmid, NULL, 0);
-        /* copy the validation values to the shared memory area  and quit*/
-        if (res->port.shm == (char *)-1)
-        {
-            ee_printf("ERROR in child shmat!\n");
-        }
-        else
-        {
-            memcpy(res->port.shm, &(res->crc), 8);
-            shmdt(res->port.shm);
-        }
-        exit(0);
-    }
-    return 1;
-}
-ee_u8
-core_stop_parallel(core_results *res)
-{
-    int   status;
-    pid_t wpid = waitpid(res->port.pid, &status, WUNTRACED);
-    if (wpid != res->port.pid)
-    {
-        ee_printf("ERROR waiting for child.\n");
-        if (errno == ECHILD)
-            ee_printf("errno=No such child %d\n", res->port.pid);
-        if (errno == EINTR)
-            ee_printf("errno=Interrupted\n");
-        return 0;
-    }
-    /* after process is done, get the values from the shared memory area */
-    res->port.shm = shmat(res->port.shmid, NULL, 0);
-    if (res->port.shm == (char *)-1)
-    {
-        ee_printf("ERROR in parent shmat!\n");
-        return 0;
-    }
-    memcpy(&(res->crc), res->port.shm, 8);
-    shmdt(res->port.shm);
-    return 1;
-}
-#elif USE_SOCKET
-static int key_id = 0;
-ee_u8
-core_start_parallel(core_results *res)
-{
-    int bound, buffer_length = 8;
-    res->port.sa.sin_family      = AF_INET;
-    res->port.sa.sin_addr.s_addr = htonl(0x7F000001);
-    res->port.sa.sin_port        = htons(7654 + key_id);
-    key_id++;
-    res->port.pid = fork();
-    if (res->port.pid == 0)
-    { /* benchmark child */
-        iterate(res);
-        res->port.sock = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);
-        if (-1 == res->port.sock) /* if socket failed to initialize, exit */
-        {
-            ee_printf("Error Creating Socket");
-        }
-        else
-        {
-            int bytes_sent = sendto(res->port.sock,
-                                    &(res->crc),
-                                    buffer_length,
-                                    0,
-                                    (struct sockaddr *)&(res->port.sa),
-                                    sizeof(struct sockaddr_in));
-            if (bytes_sent < 0)
-                ee_printf("Error sending packet: %s\n", strerror(errno));
-            close(res->port.sock); /* close the socket */
-        }
-        exit(0);
-    }
-    /* parent process, open the socket */
-    res->port.sock = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);
-    bound          = bind(res->port.sock,
-                 (struct sockaddr *)&(res->port.sa),
-                 sizeof(struct sockaddr));
-    if (bound < 0)
-        ee_printf("bind(): %s\n", strerror(errno));
-    return 1;
-}
-ee_u8
-core_stop_parallel(core_results *res)
-{
-    int status;
-    int fromlen = sizeof(struct sockaddr);
-    int recsize = recvfrom(res->port.sock,
-                           &(res->crc),
-                           8,
-                           0,
-                           (struct sockaddr *)&(res->port.sa),
-                           &fromlen);
-    if (recsize < 0)
-    {
-        ee_printf("Error in receive: %s\n", strerror(errno));
-        return 0;
-    }
-    pid_t wpid = waitpid(res->port.pid, &status, WUNTRACED);
-    if (wpid != res->port.pid)
-    {
-        ee_printf("ERROR waiting for child.\n");
-        if (errno == ECHILD)
-            ee_printf("errno=No such child %d\n", res->port.pid);
-        if (errno == EINTR)
-            ee_printf("errno=Interrupted\n");
-        return 0;
-    }
-    return 1;
-}
-#else /* no standard multicore implementation */
-#error \
-    "Please implement multicore functionality in core_portme.c to use multiple contexts."
-#endif /* multithread implementations */
-#endif
diff --git a/sw/app/coremark/linux64/core_portme.h b/sw/app/coremark/linux64/core_portme.h
deleted file mode 100644
index d90db98..0000000
--- a/sw/app/coremark/linux64/core_portme.h
+++ /dev/null
@@ -1,309 +0,0 @@
-/*
-Copyright 2018 Embedded Microprocessor Benchmark Consortium (EEMBC)
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-
-Original Author: Shay Gal-on
-*/
-
-/* Topic: Description
-        This file contains configuration constants required to execute on
-   different platforms
-*/
-#ifndef CORE_PORTME_H
-#define CORE_PORTME_H
-/************************/
-/* Data types and settings */
-/************************/
-/* Configuration: HAS_FLOAT
-        Define to 1 if the platform supports floating point.
-*/
-#ifndef HAS_FLOAT
-#define HAS_FLOAT 1
-#endif
-/* Configuration: HAS_TIME_H
-        Define to 1 if platform has the time.h header file,
-        and implementation of functions thereof.
-*/
-#ifndef HAS_TIME_H
-#define HAS_TIME_H 1
-#endif
-/* Configuration: USE_CLOCK
-        Define to 1 if platform has the time.h header file,
-        and implementation of functions thereof.
-*/
-#ifndef USE_CLOCK
-#define USE_CLOCK 0
-#endif
-/* Configuration: HAS_STDIO
-        Define to 1 if the platform has stdio.h.
-*/
-#ifndef HAS_STDIO
-#define HAS_STDIO 1
-#endif
-/* Configuration: HAS_PRINTF
-        Define to 1 if the platform has stdio.h and implements the printf
-   function.
-*/
-#ifndef HAS_PRINTF
-#define HAS_PRINTF 1
-#endif
-
-/* Configuration: CORE_TICKS
-        Define type of return from the timing functions.
- */
-#if defined(_MSC_VER)
-#include <windows.h>
-typedef size_t CORE_TICKS;
-#elif HAS_TIME_H
-#include <time.h>
-typedef clock_t CORE_TICKS;
-#else
-#error \
-    "Please define type of CORE_TICKS and implement start_time, end_time get_time and time_in_secs functions!"
-#endif
-
-/* Definitions: COMPILER_VERSION, COMPILER_FLAGS, MEM_LOCATION
-        Initialize these strings per platform
-*/
-#ifndef COMPILER_VERSION
-#ifdef __GNUC__
-#define COMPILER_VERSION "GCC"__VERSION__
-#else
-#define COMPILER_VERSION "Please put compiler version here (e.g. gcc 4.1)"
-#endif
-#endif
-#ifndef COMPILER_FLAGS
-#define COMPILER_FLAGS \
-    FLAGS_STR /* "Please put compiler flags here (e.g. -o3)" */
-#endif
-#ifndef MEM_LOCATION
-#define MEM_LOCATION                                                         \
-    "Please put data memory location here\n\t\t\t(e.g. code in flash, data " \
-    "on heap etc)"
-#define MEM_LOCATION_UNSPEC 1
-#endif
-
-/* Data Types:
-        To avoid compiler issues, define the data types that need ot be used for
-   8b, 16b and 32b in <core_portme.h>.
-
-        *Imprtant*:
-        ee_ptr_int needs to be the data type used to hold pointers, otherwise
-   coremark may fail!!!
-*/
-typedef signed short       ee_s16;
-typedef unsigned short     ee_u16;
-typedef signed int         ee_s32;
-typedef double             ee_f32;
-typedef unsigned char      ee_u8;
-typedef unsigned int       ee_u32;
-typedef unsigned long long ee_ptr_int;
-typedef size_t             ee_size_t;
-/* align an offset to point to a 32b value */
-#define align_mem(x) (void *)(4 + (((ee_ptr_int)(x)-1) & ~3))
-
-/* Configuration: SEED_METHOD
-        Defines method to get seed values that cannot be computed at compile
-   time.
-
-        Valid values:
-        SEED_ARG - from command line.
-        SEED_FUNC - from a system function.
-        SEED_VOLATILE - from volatile variables.
-*/
-#ifndef SEED_METHOD
-#define SEED_METHOD SEED_ARG
-#endif
-
-/* Configuration: MEM_METHOD
-        Defines method to get a block of memry.
-
-        Valid values:
-        MEM_MALLOC - for platforms that implement malloc and have malloc.h.
-        MEM_STATIC - to use a static memory array.
-        MEM_STACK - to allocate the data block on the stack (NYI).
-*/
-#ifndef MEM_METHOD
-#define MEM_METHOD MEM_MALLOC
-#endif
-
-/* Configuration: MULTITHREAD
-        Define for parallel execution
-
-        Valid values:
-        1 - only one context (default).
-        N>1 - will execute N copies in parallel.
-
-        Note:
-        If this flag is defined to more then 1, an implementation for launching
-   parallel contexts must be defined.
-
-        Two sample implementations are provided. Use <USE_PTHREAD> or <USE_FORK>
-   to enable them.
-
-        It is valid to have a different implementation of <core_start_parallel>
-   and <core_end_parallel> in <core_portme.c>, to fit a particular architecture.
-*/
-#ifndef MULTITHREAD
-#define MULTITHREAD 1
-#endif
-
-/* Configuration: USE_PTHREAD
-        Sample implementation for launching parallel contexts
-        This implementation uses pthread_thread_create and pthread_join.
-
-        Valid values:
-        0 - Do not use pthreads API.
-        1 - Use pthreads API
-
-        Note:
-        This flag only matters if MULTITHREAD has been defined to a value
-   greater then 1.
-*/
-#ifndef USE_PTHREAD
-#define USE_PTHREAD 0
-#endif
-
-/* Configuration: USE_FORK
-        Sample implementation for launching parallel contexts
-        This implementation uses fork, waitpid, shmget,shmat and shmdt.
-
-        Valid values:
-        0 - Do not use fork API.
-        1 - Use fork API
-
-        Note:
-        This flag only matters if MULTITHREAD has been defined to a value
-   greater then 1.
-*/
-#ifndef USE_FORK
-#define USE_FORK 0
-#endif
-
-/* Configuration: USE_SOCKET
-        Sample implementation for launching parallel contexts
-        This implementation uses fork, socket, sendto and recvfrom
-
-        Valid values:
-        0 - Do not use fork and sockets API.
-        1 - Use fork and sockets API
-
-        Note:
-        This flag only matters if MULTITHREAD has been defined to a value
-   greater then 1.
-*/
-#ifndef USE_SOCKET
-#define USE_SOCKET 0
-#endif
-
-/* Configuration: MAIN_HAS_NOARGC
-        Needed if platform does not support getting arguments to main.
-
-        Valid values:
-        0 - argc/argv to main is supported
-        1 - argc/argv to main is not supported
-*/
-#ifndef MAIN_HAS_NOARGC
-#define MAIN_HAS_NOARGC 0
-#endif
-
-/* Configuration: MAIN_HAS_NORETURN
-        Needed if platform does not support returning a value from main.
-
-        Valid values:
-        0 - main returns an int, and return value will be 0.
-        1 - platform does not support returning a value from main
-*/
-#ifndef MAIN_HAS_NORETURN
-#define MAIN_HAS_NORETURN 0
-#endif
-
-/* Variable: default_num_contexts
-        Number of contexts to spawn in multicore context.
-        Override this global value to change number of contexts used.
-
-        Note:
-        This value may not be set higher then the <MULTITHREAD> define.
-
-        To experiment, you can set the <MULTITHREAD> define to the highest value
-   expected, and use argc/argv in the <portable_init> to set this value from the
-   command line.
-*/
-extern ee_u32 default_num_contexts;
-
-#if (MULTITHREAD > 1)
-#if USE_PTHREAD
-#include <pthread.h>
-#define PARALLEL_METHOD "PThreads"
-#elif USE_FORK
-#include <unistd.h>
-#include <errno.h>
-#include <sys/wait.h>
-#include <sys/shm.h>
-#include <string.h> /* for memcpy */
-#define PARALLEL_METHOD "Fork"
-#elif USE_SOCKET
-#include <sys/types.h>
-#include <sys/socket.h>
-#include <netinet/in.h>
-#include <arpa/inet.h>
-#include <sys/wait.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-#include <errno.h>
-#define PARALLEL_METHOD "Sockets"
-#else
-#define PARALLEL_METHOD "Proprietary"
-#error \
-    "Please implement multicore functionality in core_portme.c to use multiple contexts."
-#endif /* Method for multithreading */
-#endif /* MULTITHREAD > 1 */
-
-typedef struct CORE_PORTABLE_S
-{
-#if (MULTITHREAD > 1)
-#if USE_PTHREAD
-    pthread_t thread;
-#elif USE_FORK
-    pid_t pid;
-    int   shmid;
-    void *shm;
-#elif USE_SOCKET
-    pid_t              pid;
-    int                sock;
-    struct sockaddr_in sa;
-#endif /* Method for multithreading */
-#endif /* MULTITHREAD>1 */
-    ee_u8 portable_id;
-} core_portable;
-
-/* target specific init/fini */
-void portable_init(core_portable *p, int *argc, char *argv[]);
-void portable_fini(core_portable *p);
-
-#if (SEED_METHOD == SEED_VOLATILE)
-#if (VALIDATION_RUN || PERFORMANCE_RUN || PROFILE_RUN)
-#define RUN_TYPE_FLAG 1
-#else
-#if (TOTAL_DATA_SIZE == 1200)
-#define PROFILE_RUN 1
-#else
-#define PERFORMANCE_RUN 1
-#endif
-#endif
-#endif /* SEED_METHOD==SEED_VOLATILE */
-
-#endif /* CORE_PORTME_H */
diff --git a/sw/app/coremark/linux64/core_portme.mak b/sw/app/coremark/linux64/core_portme.mak
deleted file mode 100755
index 5cfabee..0000000
--- a/sw/app/coremark/linux64/core_portme.mak
+++ /dev/null
@@ -1,140 +0,0 @@
-# Copyright 2018 Embedded Microprocessor Benchmark Consortium (EEMBC)
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#    http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-# 
-# Original Author: Shay Gal-on
-
-#File: core_portme.mak
-
-# Flag: OUTFLAG
-#	Use this flag to define how to to get an executable (e.g -o)
-OUTFLAG= -o
-# Flag: CC
-#	Use this flag to define compiler to use
-CC = gcc
-# Flag: CFLAGS
-#	Use this flag to define compiler options. Note, you can add compiler options from the command line using XCFLAGS="other flags"
-PORT_CFLAGS = -O2
-FLAGS_STR = "$(PORT_CFLAGS) $(XCFLAGS) $(XLFLAGS) $(LFLAGS_END)"
-CFLAGS = $(PORT_CFLAGS) -I$(PORT_DIR) -I. -DFLAGS_STR=\"$(FLAGS_STR)\"
-#Flag: LFLAGS_END
-#	Define any libraries needed for linking or other flags that should come at the end of the link line (e.g. linker scripts). 
-#	Note: On certain platforms, the default clock_gettime implementation is supported but requires linking of librt.
-LFLAGS_END += -lrt
-# Flag: PORT_SRCS
-# Port specific source files can be added here
-PORT_SRCS = $(PORT_DIR)/core_portme.c
-# Flag: LOAD
-#	Define this flag if you need to load to a target, as in a cross compile environment.
-
-# Flag: RUN
-#	Define this flag if running does not consist of simple invocation of the binary.
-#	In a cross compile environment, you need to define this.
-
-#For flashing and using a tera term macro, you could use
-#LOAD = flash ADDR 
-#RUN =  ttpmacro coremark.ttl
-
-#For copying to target and executing via SSH connection, you could use
-#LOAD = scp $(OUTFILE)  user@target:~
-#RUN = ssh user@target -c  
-
-#For native compilation and execution
-LOAD = echo Loading done
-RUN = 
-
-OEXT = .o
-EXE = .exe
-
-# Flag: SEPARATE_COMPILE
-# Define if you need to separate compilation from link stage. 
-# In this case, you also need to define below how to create an object file, and how to link.
-ifdef SEPARATE_COMPILE
-
-LD		= gcc
-OBJOUT 	= -o
-LFLAGS 	=
-OFLAG 	= -o
-COUT 	= -c
-# Flag: PORT_OBJS
-# Port specific object files can be added here
-PORT_OBJS = $(PORT_DIR)/core_portme$(OEXT)
-PORT_CLEAN = *$(OEXT)
-
-$(OPATH)%$(OEXT) : %.c
-	$(CC) $(CFLAGS) $(XCFLAGS) $(COUT) $< $(OBJOUT) $@
-	
-endif
-
-# Target: port_prebuild
-# Generate any files that are needed before actual build starts.
-# E.g. generate profile guidance files. Sample PGO generation for gcc enabled with PGO=1
-#  - First, check if PGO was defined on the command line, if so, need to add -fprofile-use to compile line.
-#  - Second, if PGO reference has not yet been generated, add a step to the prebuild that will build a profile-generate version and run it.
-#  Note - Using REBUILD=1 
-#
-# Use make PGO=1 to invoke this sample processing.
-
-ifdef PGO
- ifeq (,$(findstring $(PGO),gen))
-  PGO_STAGE=build_pgo_gcc
-  CFLAGS+=-fprofile-use
- endif
- PORT_CLEAN+=*.gcda *.gcno gmon.out
-endif
-
-.PHONY: port_prebuild
-port_prebuild: $(PGO_STAGE)
-
-.PHONY: build_pgo_gcc
-build_pgo_gcc:
-	$(MAKE) PGO=gen XCFLAGS="$(XCFLAGS) -fprofile-generate -DTOTAL_DATA_SIZE=1200" ITERATIONS=10 gen_pgo_data REBUILD=1
-	
-# Target: port_postbuild
-# Generate any files that are needed after actual build end.
-# E.g. change format to srec, bin, zip in order to be able to load into flash
-.PHONY: port_postbuild
-port_postbuild:
-
-# Target: port_postrun
-# 	Do platform specific after run stuff. 
-#	E.g. reset the board, backup the logfiles etc.
-.PHONY: port_postrun
-port_postrun:
-
-# Target: port_prerun
-# 	Do platform specific after run stuff. 
-#	E.g. reset the board, backup the logfiles etc.
-.PHONY: port_prerun
-port_prerun:
-
-# Target: port_postload
-# 	Do platform specific after load stuff. 
-#	E.g. reset the reset power to the flash eraser
-.PHONY: port_postload
-port_postload:
-
-# Target: port_preload
-# 	Do platform specific before load stuff. 
-#	E.g. reset the reset power to the flash eraser
-.PHONY: port_preload
-port_preload:
-
-# FLAG: OPATH
-# Path to the output folder. Default - current folder.
-OPATH = ./
-MKDIR = mkdir -p
-
-# FLAG: PERL
-# Define perl executable to calculate the geomean if running separate.
-PERL=/usr/bin/perl
diff --git a/sw/app/coremark/macos/core_portme.c b/sw/app/coremark/macos/core_portme.c
deleted file mode 100644
index 43d8ff4..0000000
--- a/sw/app/coremark/macos/core_portme.c
+++ /dev/null
@@ -1,420 +0,0 @@
-/*
-Copyright 2018 Embedded Microprocessor Benchmark Consortium (EEMBC)
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-
-Original Author: Shay Gal-on
-*/
-
-#include <stdio.h>
-#include <stdlib.h>
-#include "coremark.h"
-#if CALLGRIND_RUN
-#include <valgrind/callgrind.h>
-#endif
-
-#if (MEM_METHOD == MEM_MALLOC)
-#include <string.h>
-/* Function: portable_malloc
-        Provide malloc() functionality in a platform specific way.
-*/
-void *
-portable_malloc(size_t size)
-{
-    return malloc(size);
-}
-/* Function: portable_free
-        Provide free() functionality in a platform specific way.
-*/
-void
-portable_free(void *p)
-{
-    free(p);
-}
-#else
-void *
-portable_malloc(size_t size)
-{
-    return NULL;
-}
-void
-portable_free(void *p)
-{
-    p = NULL;
-}
-#endif
-
-#if (SEED_METHOD == SEED_VOLATILE)
-#if VALIDATION_RUN
-volatile ee_s32 seed1_volatile = 0x3415;
-volatile ee_s32 seed2_volatile = 0x3415;
-volatile ee_s32 seed3_volatile = 0x66;
-#endif
-#if PERFORMANCE_RUN
-volatile ee_s32 seed1_volatile = 0x0;
-volatile ee_s32 seed2_volatile = 0x0;
-volatile ee_s32 seed3_volatile = 0x66;
-#endif
-#if PROFILE_RUN
-volatile ee_s32 seed1_volatile = 0x8;
-volatile ee_s32 seed2_volatile = 0x8;
-volatile ee_s32 seed3_volatile = 0x8;
-#endif
-volatile ee_s32 seed4_volatile = ITERATIONS;
-volatile ee_s32 seed5_volatile = 0;
-#endif
-/* Porting: Timing functions
-        How to capture time and convert to seconds must be ported to whatever is
-   supported by the platform. e.g. Read value from on board RTC, read value from
-   cpu clock cycles performance counter etc. Sample implementation for standard
-   time.h and windows.h definitions included.
-*/
-/* Define: TIMER_RES_DIVIDER
-        Divider to trade off timer resolution and total time that can be
-   measured.
-
-        Use lower values to increase resolution, but make sure that overflow
-   does not occur. If there are issues with the return value overflowing,
-   increase this value.
-        */
-#if USE_CLOCK
-#define NSECS_PER_SEC              CLOCKS_PER_SEC
-#define EE_TIMER_TICKER_RATE       1000
-#define CORETIMETYPE               clock_t
-#define GETMYTIME(_t)              (*_t = clock())
-#define MYTIMEDIFF(fin, ini)       ((fin) - (ini))
-#define TIMER_RES_DIVIDER          1
-#define SAMPLE_TIME_IMPLEMENTATION 1
-#elif defined(_MSC_VER)
-#define NSECS_PER_SEC        10000000
-#define EE_TIMER_TICKER_RATE 1000
-#define CORETIMETYPE         FILETIME
-#define GETMYTIME(_t)        GetSystemTimeAsFileTime(_t)
-#define MYTIMEDIFF(fin, ini) \
-    (((*(__int64 *)&fin) - (*(__int64 *)&ini)) / TIMER_RES_DIVIDER)
-/* setting to millisces resolution by default with MSDEV */
-#ifndef TIMER_RES_DIVIDER
-#define TIMER_RES_DIVIDER 1000
-#endif
-#define SAMPLE_TIME_IMPLEMENTATION 1
-#elif HAS_TIME_H
-#define NSECS_PER_SEC        1000000000
-#define EE_TIMER_TICKER_RATE 1000
-#define CORETIMETYPE         struct timespec
-#define GETMYTIME(_t)        clock_gettime(CLOCK_REALTIME, _t)
-#define MYTIMEDIFF(fin, ini)                                         \
-    ((fin.tv_sec - ini.tv_sec) * (NSECS_PER_SEC / TIMER_RES_DIVIDER) \
-     + (fin.tv_nsec - ini.tv_nsec) / TIMER_RES_DIVIDER)
-/* setting to 1/1000 of a second resolution by default with linux */
-#ifndef TIMER_RES_DIVIDER
-#define TIMER_RES_DIVIDER 1000000
-#endif
-#define SAMPLE_TIME_IMPLEMENTATION 1
-#else
-#define SAMPLE_TIME_IMPLEMENTATION 0
-#endif
-#define EE_TICKS_PER_SEC (NSECS_PER_SEC / TIMER_RES_DIVIDER)
-
-#if SAMPLE_TIME_IMPLEMENTATION
-/** Define Host specific (POSIX), or target specific global time variables. */
-static CORETIMETYPE start_time_val, stop_time_val;
-
-/* Function: start_time
-        This function will be called right before starting the timed portion of
-   the benchmark.
-
-        Implementation may be capturing a system timer (as implemented in the
-   example code) or zeroing some system parameters - e.g. setting the cpu clocks
-   cycles to 0.
-*/
-void
-start_time(void)
-{
-    GETMYTIME(&start_time_val);
-#if CALLGRIND_RUN
-    CALLGRIND_START_INSTRUMENTATION
-#endif
-#if MICA
-    asm volatile("int3"); /*1 */
-#endif
-}
-/* Function: stop_time
-        This function will be called right after ending the timed portion of the
-   benchmark.
-
-        Implementation may be capturing a system timer (as implemented in the
-   example code) or other system parameters - e.g. reading the current value of
-   cpu cycles counter.
-*/
-void
-stop_time(void)
-{
-#if CALLGRIND_RUN
-    CALLGRIND_STOP_INSTRUMENTATION
-#endif
-#if MICA
-    asm volatile("int3"); /*1 */
-#endif
-    GETMYTIME(&stop_time_val);
-}
-/* Function: get_time
-        Return an abstract "ticks" number that signifies time on the system.
-
-        Actual value returned may be cpu cycles, milliseconds or any other
-   value, as long as it can be converted to seconds by <time_in_secs>. This
-   methodology is taken to accomodate any hardware or simulated platform. The
-   sample implementation returns millisecs by default, and the resolution is
-   controlled by <TIMER_RES_DIVIDER>
-*/
-CORE_TICKS
-get_time(void)
-{
-    CORE_TICKS elapsed
-        = (CORE_TICKS)(MYTIMEDIFF(stop_time_val, start_time_val));
-    return elapsed;
-}
-/* Function: time_in_secs
-        Convert the value returned by get_time to seconds.
-
-        The <secs_ret> type is used to accomodate systems with no support for
-   floating point. Default implementation implemented by the EE_TICKS_PER_SEC
-   macro above.
-*/
-secs_ret
-time_in_secs(CORE_TICKS ticks)
-{
-    secs_ret retval = ((secs_ret)ticks) / (secs_ret)EE_TICKS_PER_SEC;
-    return retval;
-}
-#else
-#error "Please implement timing functionality in core_portme.c"
-#endif /* SAMPLE_TIME_IMPLEMENTATION */
-
-ee_u32 default_num_contexts = MULTITHREAD;
-
-/* Function: portable_init
-        Target specific initialization code
-        Test for some common mistakes.
-*/
-void
-portable_init(core_portable *p, int *argc, char *argv[])
-{
-#if PRINT_ARGS
-    int i;
-    for (i = 0; i < *argc; i++)
-    {
-        ee_printf("Arg[%d]=%s\n", i, argv[i]);
-    }
-#endif
-    if (sizeof(ee_ptr_int) != sizeof(ee_u8 *))
-    {
-        ee_printf(
-            "ERROR! Please define ee_ptr_int to a type that holds a "
-            "pointer!\n");
-    }
-    if (sizeof(ee_u32) != 4)
-    {
-        ee_printf("ERROR! Please define ee_u32 to a 32b unsigned type!\n");
-    }
-#if (MAIN_HAS_NOARGC && (SEED_METHOD == SEED_ARG))
-    ee_printf(
-        "ERROR! Main has no argc, but SEED_METHOD defined to SEED_ARG!\n");
-#endif
-
-#if (MULTITHREAD > 1) && (SEED_METHOD == SEED_ARG)
-    int nargs = *argc, i;
-    if ((nargs > 1) && (*argv[1] == 'M'))
-    {
-        default_num_contexts = parseval(argv[1] + 1);
-        if (default_num_contexts > MULTITHREAD)
-            default_num_contexts = MULTITHREAD;
-        /* Shift args since first arg is directed to the portable part and not
-         * to coremark main */
-        --nargs;
-        for (i = 1; i < nargs; i++)
-            argv[i] = argv[i + 1];
-        *argc = nargs;
-    }
-#endif /* sample of potential platform specific init via command line, reset \
-          the number of contexts being used if first argument is M<n>*/
-    p->portable_id = 1;
-}
-/* Function: portable_fini
-        Target specific final code
-*/
-void
-portable_fini(core_portable *p)
-{
-    p->portable_id = 0;
-}
-
-#if (MULTITHREAD > 1)
-
-/* Function: core_start_parallel
-        Start benchmarking in a parallel context.
-
-        Three implementations are provided, one using pthreads, one using fork
-   and shared mem, and one using fork and sockets. Other implementations using
-   MCAPI or other standards can easily be devised.
-*/
-/* Function: core_stop_parallel
-        Stop a parallel context execution of coremark, and gather the results.
-
-        Three implementations are provided, one using pthreads, one using fork
-   and shared mem, and one using fork and sockets. Other implementations using
-   MCAPI or other standards can easily be devised.
-*/
-#if USE_PTHREAD
-ee_u8
-core_start_parallel(core_results *res)
-{
-    return (ee_u8)pthread_create(
-        &(res->port.thread), NULL, iterate, (void *)res);
-}
-ee_u8
-core_stop_parallel(core_results *res)
-{
-    void *retval;
-    return (ee_u8)pthread_join(res->port.thread, &retval);
-}
-#elif USE_FORK
-static int key_id = 0;
-ee_u8
-core_start_parallel(core_results *res)
-{
-    key_t key = 4321 + key_id;
-    key_id++;
-    res->port.pid   = fork();
-    res->port.shmid = shmget(key, 8, IPC_CREAT | 0666);
-    if (res->port.shmid < 0)
-    {
-        ee_printf("ERROR in shmget!\n");
-    }
-    if (res->port.pid == 0)
-    {
-        iterate(res);
-        res->port.shm = shmat(res->port.shmid, NULL, 0);
-        /* copy the validation values to the shared memory area  and quit*/
-        if (res->port.shm == (char *)-1)
-        {
-            ee_printf("ERROR in child shmat!\n");
-        }
-        else
-        {
-            memcpy(res->port.shm, &(res->crc), 8);
-            shmdt(res->port.shm);
-        }
-        exit(0);
-    }
-    return 1;
-}
-ee_u8
-core_stop_parallel(core_results *res)
-{
-    int   status;
-    pid_t wpid = waitpid(res->port.pid, &status, WUNTRACED);
-    if (wpid != res->port.pid)
-    {
-        ee_printf("ERROR waiting for child.\n");
-        if (errno == ECHILD)
-            ee_printf("errno=No such child %d\n", res->port.pid);
-        if (errno == EINTR)
-            ee_printf("errno=Interrupted\n");
-        return 0;
-    }
-    /* after process is done, get the values from the shared memory area */
-    res->port.shm = shmat(res->port.shmid, NULL, 0);
-    if (res->port.shm == (char *)-1)
-    {
-        ee_printf("ERROR in parent shmat!\n");
-        return 0;
-    }
-    memcpy(&(res->crc), res->port.shm, 8);
-    shmdt(res->port.shm);
-    return 1;
-}
-#elif USE_SOCKET
-static int key_id = 0;
-ee_u8
-core_start_parallel(core_results *res)
-{
-    int bound, buffer_length = 8;
-    res->port.sa.sin_family      = AF_INET;
-    res->port.sa.sin_addr.s_addr = htonl(0x7F000001);
-    res->port.sa.sin_port        = htons(7654 + key_id);
-    key_id++;
-    res->port.pid = fork();
-    if (res->port.pid == 0)
-    { /* benchmark child */
-        iterate(res);
-        res->port.sock = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);
-        if (-1 == res->port.sock) /* if socket failed to initialize, exit */
-        {
-            ee_printf("Error Creating Socket");
-        }
-        else
-        {
-            int bytes_sent = sendto(res->port.sock,
-                                    &(res->crc),
-                                    buffer_length,
-                                    0,
-                                    (struct sockaddr *)&(res->port.sa),
-                                    sizeof(struct sockaddr_in));
-            if (bytes_sent < 0)
-                ee_printf("Error sending packet: %s\n", strerror(errno));
-            close(res->port.sock); /* close the socket */
-        }
-        exit(0);
-    }
-    /* parent process, open the socket */
-    res->port.sock = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);
-    bound          = bind(res->port.sock,
-                 (struct sockaddr *)&(res->port.sa),
-                 sizeof(struct sockaddr));
-    if (bound < 0)
-        ee_printf("bind(): %s\n", strerror(errno));
-    return 1;
-}
-ee_u8
-core_stop_parallel(core_results *res)
-{
-    int status;
-    int fromlen = sizeof(struct sockaddr);
-    int recsize = recvfrom(res->port.sock,
-                           &(res->crc),
-                           8,
-                           0,
-                           (struct sockaddr *)&(res->port.sa),
-                           &fromlen);
-    if (recsize < 0)
-    {
-        ee_printf("Error in receive: %s\n", strerror(errno));
-        return 0;
-    }
-    pid_t wpid = waitpid(res->port.pid, &status, WUNTRACED);
-    if (wpid != res->port.pid)
-    {
-        ee_printf("ERROR waiting for child.\n");
-        if (errno == ECHILD)
-            ee_printf("errno=No such child %d\n", res->port.pid);
-        if (errno == EINTR)
-            ee_printf("errno=Interrupted\n");
-        return 0;
-    }
-    return 1;
-}
-#else /* no standard multicore implementation */
-#error \
-    "Please implement multicore functionality in core_portme.c to use multiple contexts."
-#endif /* multithread implementations */
-#endif
diff --git a/sw/app/coremark/macos/core_portme.h b/sw/app/coremark/macos/core_portme.h
deleted file mode 100644
index d90db98..0000000
--- a/sw/app/coremark/macos/core_portme.h
+++ /dev/null
@@ -1,309 +0,0 @@
-/*
-Copyright 2018 Embedded Microprocessor Benchmark Consortium (EEMBC)
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-
-Original Author: Shay Gal-on
-*/
-
-/* Topic: Description
-        This file contains configuration constants required to execute on
-   different platforms
-*/
-#ifndef CORE_PORTME_H
-#define CORE_PORTME_H
-/************************/
-/* Data types and settings */
-/************************/
-/* Configuration: HAS_FLOAT
-        Define to 1 if the platform supports floating point.
-*/
-#ifndef HAS_FLOAT
-#define HAS_FLOAT 1
-#endif
-/* Configuration: HAS_TIME_H
-        Define to 1 if platform has the time.h header file,
-        and implementation of functions thereof.
-*/
-#ifndef HAS_TIME_H
-#define HAS_TIME_H 1
-#endif
-/* Configuration: USE_CLOCK
-        Define to 1 if platform has the time.h header file,
-        and implementation of functions thereof.
-*/
-#ifndef USE_CLOCK
-#define USE_CLOCK 0
-#endif
-/* Configuration: HAS_STDIO
-        Define to 1 if the platform has stdio.h.
-*/
-#ifndef HAS_STDIO
-#define HAS_STDIO 1
-#endif
-/* Configuration: HAS_PRINTF
-        Define to 1 if the platform has stdio.h and implements the printf
-   function.
-*/
-#ifndef HAS_PRINTF
-#define HAS_PRINTF 1
-#endif
-
-/* Configuration: CORE_TICKS
-        Define type of return from the timing functions.
- */
-#if defined(_MSC_VER)
-#include <windows.h>
-typedef size_t CORE_TICKS;
-#elif HAS_TIME_H
-#include <time.h>
-typedef clock_t CORE_TICKS;
-#else
-#error \
-    "Please define type of CORE_TICKS and implement start_time, end_time get_time and time_in_secs functions!"
-#endif
-
-/* Definitions: COMPILER_VERSION, COMPILER_FLAGS, MEM_LOCATION
-        Initialize these strings per platform
-*/
-#ifndef COMPILER_VERSION
-#ifdef __GNUC__
-#define COMPILER_VERSION "GCC"__VERSION__
-#else
-#define COMPILER_VERSION "Please put compiler version here (e.g. gcc 4.1)"
-#endif
-#endif
-#ifndef COMPILER_FLAGS
-#define COMPILER_FLAGS \
-    FLAGS_STR /* "Please put compiler flags here (e.g. -o3)" */
-#endif
-#ifndef MEM_LOCATION
-#define MEM_LOCATION                                                         \
-    "Please put data memory location here\n\t\t\t(e.g. code in flash, data " \
-    "on heap etc)"
-#define MEM_LOCATION_UNSPEC 1
-#endif
-
-/* Data Types:
-        To avoid compiler issues, define the data types that need ot be used for
-   8b, 16b and 32b in <core_portme.h>.
-
-        *Imprtant*:
-        ee_ptr_int needs to be the data type used to hold pointers, otherwise
-   coremark may fail!!!
-*/
-typedef signed short       ee_s16;
-typedef unsigned short     ee_u16;
-typedef signed int         ee_s32;
-typedef double             ee_f32;
-typedef unsigned char      ee_u8;
-typedef unsigned int       ee_u32;
-typedef unsigned long long ee_ptr_int;
-typedef size_t             ee_size_t;
-/* align an offset to point to a 32b value */
-#define align_mem(x) (void *)(4 + (((ee_ptr_int)(x)-1) & ~3))
-
-/* Configuration: SEED_METHOD
-        Defines method to get seed values that cannot be computed at compile
-   time.
-
-        Valid values:
-        SEED_ARG - from command line.
-        SEED_FUNC - from a system function.
-        SEED_VOLATILE - from volatile variables.
-*/
-#ifndef SEED_METHOD
-#define SEED_METHOD SEED_ARG
-#endif
-
-/* Configuration: MEM_METHOD
-        Defines method to get a block of memry.
-
-        Valid values:
-        MEM_MALLOC - for platforms that implement malloc and have malloc.h.
-        MEM_STATIC - to use a static memory array.
-        MEM_STACK - to allocate the data block on the stack (NYI).
-*/
-#ifndef MEM_METHOD
-#define MEM_METHOD MEM_MALLOC
-#endif
-
-/* Configuration: MULTITHREAD
-        Define for parallel execution
-
-        Valid values:
-        1 - only one context (default).
-        N>1 - will execute N copies in parallel.
-
-        Note:
-        If this flag is defined to more then 1, an implementation for launching
-   parallel contexts must be defined.
-
-        Two sample implementations are provided. Use <USE_PTHREAD> or <USE_FORK>
-   to enable them.
-
-        It is valid to have a different implementation of <core_start_parallel>
-   and <core_end_parallel> in <core_portme.c>, to fit a particular architecture.
-*/
-#ifndef MULTITHREAD
-#define MULTITHREAD 1
-#endif
-
-/* Configuration: USE_PTHREAD
-        Sample implementation for launching parallel contexts
-        This implementation uses pthread_thread_create and pthread_join.
-
-        Valid values:
-        0 - Do not use pthreads API.
-        1 - Use pthreads API
-
-        Note:
-        This flag only matters if MULTITHREAD has been defined to a value
-   greater then 1.
-*/
-#ifndef USE_PTHREAD
-#define USE_PTHREAD 0
-#endif
-
-/* Configuration: USE_FORK
-        Sample implementation for launching parallel contexts
-        This implementation uses fork, waitpid, shmget,shmat and shmdt.
-
-        Valid values:
-        0 - Do not use fork API.
-        1 - Use fork API
-
-        Note:
-        This flag only matters if MULTITHREAD has been defined to a value
-   greater then 1.
-*/
-#ifndef USE_FORK
-#define USE_FORK 0
-#endif
-
-/* Configuration: USE_SOCKET
-        Sample implementation for launching parallel contexts
-        This implementation uses fork, socket, sendto and recvfrom
-
-        Valid values:
-        0 - Do not use fork and sockets API.
-        1 - Use fork and sockets API
-
-        Note:
-        This flag only matters if MULTITHREAD has been defined to a value
-   greater then 1.
-*/
-#ifndef USE_SOCKET
-#define USE_SOCKET 0
-#endif
-
-/* Configuration: MAIN_HAS_NOARGC
-        Needed if platform does not support getting arguments to main.
-
-        Valid values:
-        0 - argc/argv to main is supported
-        1 - argc/argv to main is not supported
-*/
-#ifndef MAIN_HAS_NOARGC
-#define MAIN_HAS_NOARGC 0
-#endif
-
-/* Configuration: MAIN_HAS_NORETURN
-        Needed if platform does not support returning a value from main.
-
-        Valid values:
-        0 - main returns an int, and return value will be 0.
-        1 - platform does not support returning a value from main
-*/
-#ifndef MAIN_HAS_NORETURN
-#define MAIN_HAS_NORETURN 0
-#endif
-
-/* Variable: default_num_contexts
-        Number of contexts to spawn in multicore context.
-        Override this global value to change number of contexts used.
-
-        Note:
-        This value may not be set higher then the <MULTITHREAD> define.
-
-        To experiment, you can set the <MULTITHREAD> define to the highest value
-   expected, and use argc/argv in the <portable_init> to set this value from the
-   command line.
-*/
-extern ee_u32 default_num_contexts;
-
-#if (MULTITHREAD > 1)
-#if USE_PTHREAD
-#include <pthread.h>
-#define PARALLEL_METHOD "PThreads"
-#elif USE_FORK
-#include <unistd.h>
-#include <errno.h>
-#include <sys/wait.h>
-#include <sys/shm.h>
-#include <string.h> /* for memcpy */
-#define PARALLEL_METHOD "Fork"
-#elif USE_SOCKET
-#include <sys/types.h>
-#include <sys/socket.h>
-#include <netinet/in.h>
-#include <arpa/inet.h>
-#include <sys/wait.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-#include <errno.h>
-#define PARALLEL_METHOD "Sockets"
-#else
-#define PARALLEL_METHOD "Proprietary"
-#error \
-    "Please implement multicore functionality in core_portme.c to use multiple contexts."
-#endif /* Method for multithreading */
-#endif /* MULTITHREAD > 1 */
-
-typedef struct CORE_PORTABLE_S
-{
-#if (MULTITHREAD > 1)
-#if USE_PTHREAD
-    pthread_t thread;
-#elif USE_FORK
-    pid_t pid;
-    int   shmid;
-    void *shm;
-#elif USE_SOCKET
-    pid_t              pid;
-    int                sock;
-    struct sockaddr_in sa;
-#endif /* Method for multithreading */
-#endif /* MULTITHREAD>1 */
-    ee_u8 portable_id;
-} core_portable;
-
-/* target specific init/fini */
-void portable_init(core_portable *p, int *argc, char *argv[]);
-void portable_fini(core_portable *p);
-
-#if (SEED_METHOD == SEED_VOLATILE)
-#if (VALIDATION_RUN || PERFORMANCE_RUN || PROFILE_RUN)
-#define RUN_TYPE_FLAG 1
-#else
-#if (TOTAL_DATA_SIZE == 1200)
-#define PROFILE_RUN 1
-#else
-#define PERFORMANCE_RUN 1
-#endif
-#endif
-#endif /* SEED_METHOD==SEED_VOLATILE */
-
-#endif /* CORE_PORTME_H */
diff --git a/sw/app/coremark/macos/core_portme.mak b/sw/app/coremark/macos/core_portme.mak
deleted file mode 100755
index ff0f8eb..0000000
--- a/sw/app/coremark/macos/core_portme.mak
+++ /dev/null
@@ -1,140 +0,0 @@
-# Copyright 2018 Embedded Microprocessor Benchmark Consortium (EEMBC)
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#    http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-# 
-# Original Author: Shay Gal-on
-
-#File: core_portme.mak
-
-# Flag: OUTFLAG
-#	Use this flag to define how to to get an executable (e.g -o)
-OUTFLAG= -o
-# Flag: CC
-#	Use this flag to define compiler to use
-CC = gcc
-# Flag: CFLAGS
-#	Use this flag to define compiler options. Note, you can add compiler options from the command line using XCFLAGS="other flags"
-PORT_CFLAGS = -O2
-FLAGS_STR = "$(PORT_CFLAGS) $(XCFLAGS) $(XLFLAGS) $(LFLAGS_END)"
-CFLAGS = $(PORT_CFLAGS) -I$(PORT_DIR) -I. -DFLAGS_STR=\"$(FLAGS_STR)\"
-#Flag: LFLAGS_END
-#	Define any libraries needed for linking or other flags that should come at the end of the link line (e.g. linker scripts). 
-#	Note: On certain platforms, the default clock_gettime implementation is supported but requires linking of librt.
-#LFLAGS_END += -lrt
-# Flag: PORT_SRCS
-# Port specific source files can be added here
-PORT_SRCS = $(PORT_DIR)/core_portme.c
-# Flag: LOAD
-#	Define this flag if you need to load to a target, as in a cross compile environment.
-
-# Flag: RUN
-#	Define this flag if running does not consist of simple invocation of the binary.
-#	In a cross compile environment, you need to define this.
-
-#For flashing and using a tera term macro, you could use
-#LOAD = flash ADDR 
-#RUN =  ttpmacro coremark.ttl
-
-#For copying to target and executing via SSH connection, you could use
-#LOAD = scp $(OUTFILE)  user@target:~
-#RUN = ssh user@target -c  
-
-#For native compilation and execution
-LOAD = echo Loading done
-RUN = 
-
-OEXT = .o
-EXE = .exe
-
-# Flag: SEPARATE_COMPILE
-# Define if you need to separate compilation from link stage. 
-# In this case, you also need to define below how to create an object file, and how to link.
-ifdef SEPARATE_COMPILE
-
-LD		= gcc
-OBJOUT 	= -o
-LFLAGS 	=
-OFLAG 	= -o
-COUT 	= -c
-# Flag: PORT_OBJS
-# Port specific object files can be added here
-PORT_OBJS = $(PORT_DIR)/core_portme$(OEXT)
-PORT_CLEAN = *$(OEXT)
-
-$(OPATH)%$(OEXT) : %.c
-	$(CC) $(CFLAGS) $(XCFLAGS) $(COUT) $< $(OBJOUT) $@
-	
-endif
-
-# Target: port_prebuild
-# Generate any files that are needed before actual build starts.
-# E.g. generate profile guidance files. Sample PGO generation for gcc enabled with PGO=1
-#  - First, check if PGO was defined on the command line, if so, need to add -fprofile-use to compile line.
-#  - Second, if PGO reference has not yet been generated, add a step to the prebuild that will build a profile-generate version and run it.
-#  Note - Using REBUILD=1 
-#
-# Use make PGO=1 to invoke this sample processing.
-
-ifdef PGO
- ifeq (,$(findstring $(PGO),gen))
-  PGO_STAGE=build_pgo_gcc
-  CFLAGS+=-fprofile-use
- endif
- PORT_CLEAN+=*.gcda *.gcno gmon.out
-endif
-
-.PHONY: port_prebuild
-port_prebuild: $(PGO_STAGE)
-
-.PHONY: build_pgo_gcc
-build_pgo_gcc:
-	$(MAKE) PGO=gen XCFLAGS="$(XCFLAGS) -fprofile-generate -DTOTAL_DATA_SIZE=1200" ITERATIONS=10 gen_pgo_data REBUILD=1
-	
-# Target: port_postbuild
-# Generate any files that are needed after actual build end.
-# E.g. change format to srec, bin, zip in order to be able to load into flash
-.PHONY: port_postbuild
-port_postbuild:
-
-# Target: port_postrun
-# 	Do platform specific after run stuff. 
-#	E.g. reset the board, backup the logfiles etc.
-.PHONY: port_postrun
-port_postrun:
-
-# Target: port_prerun
-# 	Do platform specific after run stuff. 
-#	E.g. reset the board, backup the logfiles etc.
-.PHONY: port_prerun
-port_prerun:
-
-# Target: port_postload
-# 	Do platform specific after load stuff. 
-#	E.g. reset the reset power to the flash eraser
-.PHONY: port_postload
-port_postload:
-
-# Target: port_preload
-# 	Do platform specific before load stuff. 
-#	E.g. reset the reset power to the flash eraser
-.PHONY: port_preload
-port_preload:
-
-# FLAG: OPATH
-# Path to the output folder. Default - current folder.
-OPATH = ./
-MKDIR = mkdir -p
-
-# FLAG: PERL
-# Define perl executable to calculate the geomean if running separate.
-PERL=/usr/bin/perl
diff --git a/sw/app/coremark/rtems/core_portme.c b/sw/app/coremark/rtems/core_portme.c
deleted file mode 100755
index 24e1ca4..0000000
--- a/sw/app/coremark/rtems/core_portme.c
+++ /dev/null
@@ -1,364 +0,0 @@
-/*
-Copyright 2020 Hesham Almatary
-Copyright 2018 Embedded Microprocessor Benchmark Consortium (EEMBC)
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-
-Original Author: Shay Gal-on
-*/
-
-#include <stdio.h>
-#include <stdlib.h>
-#include "coremark.h"
-#if CALLGRIND_RUN
-#include <valgrind/callgrind.h>
-#endif
-
-#include <bsp.h>
-
-int main( int, char ** );
-
-#if (MEM_METHOD==MEM_MALLOC)
-/* Function: portable_malloc
-	Provide malloc() functionality in a platform specific way.
-*/
-void *portable_malloc(size_t size) {
-	return malloc(size);
-}
-/* Function: portable_free
-	Provide free() functionality in a platform specific way.
-*/
-void portable_free(void *p) {
-	free(p);
-}
-#else
-void *portable_malloc(size_t size) {
-	return NULL;
-}
-void portable_free(void *p) {
-	p=NULL;
-}
-#endif
-
-#if (SEED_METHOD==SEED_VOLATILE)
-#if VALIDATION_RUN
-	volatile ee_s32 seed1_volatile=0x3415;
-	volatile ee_s32 seed2_volatile=0x3415;
-	volatile ee_s32 seed3_volatile=0x66;
-#endif
-#if PERFORMANCE_RUN
-	volatile ee_s32 seed1_volatile=0x0;
-	volatile ee_s32 seed2_volatile=0x0;
-	volatile ee_s32 seed3_volatile=0x66;
-#endif
-#if PROFILE_RUN
-	volatile ee_s32 seed1_volatile=0x8;
-	volatile ee_s32 seed2_volatile=0x8;
-	volatile ee_s32 seed3_volatile=0x8;
-#endif
-	volatile ee_s32 seed4_volatile=ITERATIONS;
-	volatile ee_s32 seed5_volatile=0;
-#endif
-/* Porting: Timing functions
-	How to capture time and convert to seconds must be ported to whatever is supported by the platform.
-	e.g. Read value from on board RTC, read value from cpu clock cycles performance counter etc. 
-	Sample implementation for standard time.h and windows.h definitions included.
-*/
-/* Define: TIMER_RES_DIVIDER
-	Divider to trade off timer resolution and total time that can be measured.
-
-	Use lower values to increase resolution, but make sure that overflow does not occur.
-	If there are issues with the return value overflowing, increase this value.
-	*/
-#if USE_CLOCK
-	#define NSECS_PER_SEC CLOCKS_PER_SEC
-	#define EE_TIMER_TICKER_RATE 1000
-	#define CORETIMETYPE clock_t 
-	#define GETMYTIME(_t) (*_t=clock())
-	#define MYTIMEDIFF(fin,ini) ((fin)-(ini))
-	#define TIMER_RES_DIVIDER 1
-	#define SAMPLE_TIME_IMPLEMENTATION 1
-#elif defined(_MSC_VER)
-	#define NSECS_PER_SEC 10000000
-	#define EE_TIMER_TICKER_RATE 1000
-	#define CORETIMETYPE FILETIME
-	#define GETMYTIME(_t) GetSystemTimeAsFileTime(_t)
-	#define MYTIMEDIFF(fin,ini) (((*(__int64*)&fin)-(*(__int64*)&ini))/TIMER_RES_DIVIDER)
-	/* setting to millisces resolution by default with MSDEV */
-	#ifndef TIMER_RES_DIVIDER
-	#define TIMER_RES_DIVIDER 1000
-	#endif
-	#define SAMPLE_TIME_IMPLEMENTATION 1
-#elif HAS_TIME_H
-	#define NSECS_PER_SEC 1000000000
-	#define EE_TIMER_TICKER_RATE 1000
-	#define CORETIMETYPE struct timespec 
-	#define GETMYTIME(_t) clock_gettime(CLOCK_REALTIME,_t)
-	#define MYTIMEDIFF(fin,ini) ((fin.tv_sec-ini.tv_sec)*(NSECS_PER_SEC/TIMER_RES_DIVIDER)+(fin.tv_nsec-ini.tv_nsec)/TIMER_RES_DIVIDER)
-	/* setting to 1/1000 of a second resolution by default with linux */
-	#ifndef TIMER_RES_DIVIDER
-	#define TIMER_RES_DIVIDER 1000000
-	#endif
-	#define SAMPLE_TIME_IMPLEMENTATION 1
-#else
-	#define SAMPLE_TIME_IMPLEMENTATION 0
-#endif
-#define EE_TICKS_PER_SEC (NSECS_PER_SEC / TIMER_RES_DIVIDER)
-
-#if SAMPLE_TIME_IMPLEMENTATION
-/** Define Host specific (POSIX), or target specific global time variables. */
-static CORETIMETYPE start_time_val, stop_time_val;
-
-/* Function: start_time
-	This function will be called right before starting the timed portion of the benchmark.
-
-	Implementation may be capturing a system timer (as implemented in the example code) 
-	or zeroing some system parameters - e.g. setting the cpu clocks cycles to 0.
-*/
-void start_time(void) {
-	GETMYTIME(&start_time_val );      
-#if CALLGRIND_RUN
-	CALLGRIND_START_INSTRUMENTATION
-#endif
-#if MICA
-    asm volatile("int3");/*1 */
-#endif
-}
-/* Function: stop_time
-	This function will be called right after ending the timed portion of the benchmark.
-
-	Implementation may be capturing a system timer (as implemented in the example code) 
-	or other system parameters - e.g. reading the current value of cpu cycles counter.
-*/
-void stop_time(void) {
-#if CALLGRIND_RUN
-	 CALLGRIND_STOP_INSTRUMENTATION 
-#endif
-#if MICA
-    asm volatile("int3");/*1 */
-#endif
-	GETMYTIME(&stop_time_val );      
-}
-/* Function: get_time
-	Return an abstract "ticks" number that signifies time on the system.
-	
-	Actual value returned may be cpu cycles, milliseconds or any other value,
-	as long as it can be converted to seconds by <time_in_secs>.
-	This methodology is taken to accomodate any hardware or simulated platform.
-	The sample implementation returns millisecs by default, 
-	and the resolution is controlled by <TIMER_RES_DIVIDER>
-*/
-CORE_TICKS get_time(void) {
-	CORE_TICKS elapsed=(CORE_TICKS)(MYTIMEDIFF(stop_time_val, start_time_val));
-	return elapsed;
-}
-/* Function: time_in_secs
-	Convert the value returned by get_time to seconds.
-
-	The <secs_ret> type is used to accomodate systems with no support for floating point.
-	Default implementation implemented by the EE_TICKS_PER_SEC macro above.
-*/
-secs_ret time_in_secs(CORE_TICKS ticks) {
-	secs_ret retval=((secs_ret)ticks) / (secs_ret)EE_TICKS_PER_SEC;
-	return retval;
-}
-#else 
-#error "Please implement timing functionality in core_portme.c"
-#endif /* SAMPLE_TIME_IMPLEMENTATION */
-
-ee_u32 default_num_contexts=MULTITHREAD;
-
-/* Function: portable_init
-	Target specific initialization code 
-	Test for some common mistakes.
-*/
-void portable_init(core_portable *p, int *argc, char *argv[])
-{
-#if PRINT_ARGS
-	int i;
-	for (i=0; i<*argc; i++) {
-		ee_printf("Arg[%d]=%s\n",i,argv[i]);
-	}
-#endif
-	if (sizeof(ee_ptr_int) != sizeof(ee_u8 *)) {
-		ee_printf("ERROR! Please define ee_ptr_int to a type that holds a pointer!\n");
-	}
-	if (sizeof(ee_u32) != 4) {
-		ee_printf("ERROR! Please define ee_u32 to a 32b unsigned type!\n");
-	}
-#if (MAIN_HAS_NOARGC && (SEED_METHOD==SEED_ARG))
-	ee_printf("ERROR! Main has no argc, but SEED_METHOD defined to SEED_ARG!\n");
-#endif
-	
-#if (MULTITHREAD>1) && (SEED_METHOD==SEED_ARG)
-	int nargs=*argc,i;
-	if ((nargs>1) && (*argv[1]=='M')) {
-		default_num_contexts=parseval(argv[1]+1);
-		if (default_num_contexts>MULTITHREAD)
-			default_num_contexts=MULTITHREAD;
-		/* Shift args since first arg is directed to the portable part and not to coremark main */
-		--nargs;
-		for (i=1; i<nargs; i++)
-			argv[i]=argv[i+1];
-		*argc=nargs;
-	}
-#endif /* sample of potential platform specific init via command line, reset the number of contexts being used if first argument is M<n>*/
-	p->portable_id=1;
-}
-/* Function: portable_fini
-	Target specific final code 
-*/
-void portable_fini(core_portable *p)
-{
-	p->portable_id=0;
-}
-
-#if (MULTITHREAD>1)
-
-/* Function: core_start_parallel
-	Start benchmarking in a parallel context.
-	
-	Three implementations are provided, one using pthreads, one using fork and shared mem, and one using fork and sockets.
-	Other implementations using MCAPI or other standards can easily be devised.
-*/
-/* Function: core_stop_parallel
-	Stop a parallel context execution of coremark, and gather the results.
-	
-	Three implementations are provided, one using pthreads, one using fork and shared mem, and one using fork and sockets.
-	Other implementations using MCAPI or other standards can easily be devised.
-*/
-#if USE_PTHREAD
-ee_u8 core_start_parallel(core_results *res) {
-	return (ee_u8)pthread_create(&(res->port.thread),NULL,iterate,(void *)res);
-}
-ee_u8 core_stop_parallel(core_results *res) {
-	void *retval;
-	return (ee_u8)pthread_join(res->port.thread,&retval);
-}
-#elif USE_FORK
-static int key_id=0;
-ee_u8 core_start_parallel(core_results *res) {
-	key_t key=4321+key_id;
-	key_id++;
-	res->port.pid=fork();
-	res->port.shmid=shmget(key, 8, IPC_CREAT | 0666);
-	if (res->port.shmid<0) {
-		ee_printf("ERROR in shmget!\n");
-	}
-	if (res->port.pid==0) {
-		iterate(res);
-		res->port.shm=shmat(res->port.shmid, NULL, 0);
-		/* copy the validation values to the shared memory area  and quit*/
-		if (res->port.shm == (char *) -1) {
-			ee_printf("ERROR in child shmat!\n");
-		} else {
-			memcpy(res->port.shm,&(res->crc),8);
-			shmdt(res->port.shm);
-		}
-		exit(0);
-	}
-	return 1;
-}
-ee_u8 core_stop_parallel(core_results *res) {
-	int status;
-	pid_t wpid = waitpid(res->port.pid,&status,WUNTRACED);
-	if (wpid != res->port.pid) {
-		ee_printf("ERROR waiting for child.\n");
-		if (errno == ECHILD) ee_printf("errno=No such child %d\n",res->port.pid);
-		if (errno == EINTR) ee_printf("errno=Interrupted\n");
-		return 0;
-	}
-	/* after process is done, get the values from the shared memory area */
-	res->port.shm=shmat(res->port.shmid, NULL, 0);
-	if (res->port.shm == (char *) -1) {
-		ee_printf("ERROR in parent shmat!\n");
-		return 0;
-	} 
-	memcpy(&(res->crc),res->port.shm,8);
-	shmdt(res->port.shm);
-	return 1;
-}
-#elif USE_SOCKET
-static int key_id=0;
-ee_u8 core_start_parallel(core_results *res) {
-	int bound, buffer_length=8;
-	res->port.sa.sin_family = AF_INET;
-	res->port.sa.sin_addr.s_addr = htonl(0x7F000001);
-	res->port.sa.sin_port = htons(7654+key_id);
-	key_id++;
-	res->port.pid=fork();
-	if (res->port.pid==0) { /* benchmark child */
-		iterate(res);
-		res->port.sock = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);
-		if (-1 == res->port.sock) /* if socket failed to initialize, exit */   {
-			ee_printf("Error Creating Socket");
-		} else {
-			int bytes_sent = sendto(res->port.sock, &(res->crc), buffer_length, 0,(struct sockaddr*)&(res->port.sa), sizeof (struct sockaddr_in));
-			if (bytes_sent < 0)
-				ee_printf("Error sending packet: %s\n", strerror(errno));
-			close(res->port.sock); /* close the socket */
-		}
-		exit(0);
-	} 
-	/* parent process, open the socket */
-	res->port.sock = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);
-	bound = bind(res->port.sock,(struct sockaddr*)&(res->port.sa), sizeof(struct sockaddr));
-	if (bound < 0)
-		ee_printf("bind(): %s\n",strerror(errno));
-	return 1;
-}
-ee_u8 core_stop_parallel(core_results *res) {
-	int status;
-	int fromlen=sizeof(struct sockaddr);
-	int recsize = recvfrom(res->port.sock, &(res->crc), 8, 0, (struct sockaddr*)&(res->port.sa), &fromlen);
-	if (recsize < 0) {
-		ee_printf("Error in receive: %s\n", strerror(errno));
-		return 0;
-	}
-	pid_t wpid = waitpid(res->port.pid,&status,WUNTRACED);
-	if (wpid != res->port.pid) {
-		ee_printf("ERROR waiting for child.\n");
-		if (errno == ECHILD) ee_printf("errno=No such child %d\n",res->port.pid);
-		if (errno == EINTR) ee_printf("errno=Interrupted\n");
-		return 0;
-	}
-	return 1;
-}
-#else /* no standard multicore implementation */
-#error "Please implement multicore functionality in core_portme.c to use multiple contexts."
-#endif /* multithread implementations */
-#endif
-
-rtems_task Init(
-  rtems_task_argument ignored
-);
-
-rtems_task Init(
-  rtems_task_argument ignored
-)
-{
-  int ret = main(0, NULL);
-  exit(ret);
-}
-
-/* configuration information */
-#define CONFIGURE_APPLICATION_NEEDS_SIMPLE_CONSOLE_DRIVER
-#define CONFIGURE_APPLICATION_NEEDS_CLOCK_DRIVER
-
-#define CONFIGURE_MAXIMUM_TASKS 20
-
-#define CONFIGURE_RTEMS_INIT_TASKS_TABLE
-
-#define CONFIGURE_INIT
-
-#include <rtems/confdefs.h>
diff --git a/sw/app/coremark/rtems/core_portme.h b/sw/app/coremark/rtems/core_portme.h
deleted file mode 100755
index a54b03a..0000000
--- a/sw/app/coremark/rtems/core_portme.h
+++ /dev/null
@@ -1,305 +0,0 @@
-/*
-Copyright 2020 Hesham Almatary
-Copyright 2018 Embedded Microprocessor Benchmark Consortium (EEMBC)
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-
-Original Author: Shay Gal-on
-*/
-
-/* Topic: Description
-	This file contains configuration constants required to execute on different platforms
-*/
-#ifndef CORE_PORTME_H
-#define CORE_PORTME_H
-/************************/
-/* Data types and settings */
-/************************/
-/* Configuration: HAS_FLOAT
-	Define to 1 if the platform supports floating point.
-*/
-#ifndef HAS_FLOAT
-#define HAS_FLOAT 1
-#endif
-/* Configuration: HAS_TIME_H
-	Define to 1 if platform has the time.h header file,
-	and implementation of functions thereof.
-*/
-#ifndef HAS_TIME_H
-#define HAS_TIME_H 1
-#endif
-/* Configuration: USE_CLOCK
-	Define to 1 if platform has the time.h header file,
-	and implementation of functions thereof.
-*/
-#ifndef USE_CLOCK
-#define USE_CLOCK 1
-#endif
-/* Configuration: HAS_STDIO
-	Define to 1 if the platform has stdio.h.
-*/
-#ifndef HAS_STDIO
-#define HAS_STDIO 1
-#endif
-/* Configuration: HAS_PRINTF
-	Define to 1 if the platform has stdio.h and implements the printf function.
-*/
-#ifndef HAS_PRINTF
-#define HAS_PRINTF 1
-#endif
-
-#ifndef __has_builtin
-#define __has_builtin(x)	0
-#endif
-
-/* Configuration: CORE_TICKS
-	Define type of return from the timing functions.
- */
-#if defined(_MSC_VER)
-#include <windows.h>
-typedef size_t CORE_TICKS;
-#elif HAS_TIME_H
-#include <time.h>
-typedef clock_t CORE_TICKS;
-#else
-#error "Please define type of CORE_TICKS and implement start_time, end_time get_time and time_in_secs functions!"
-#endif
-
-/* Definitions: COMPILER_VERSION, COMPILER_FLAGS, MEM_LOCATION
-	Initialize these strings per platform
-*/
-#ifndef COMPILER_VERSION
- #ifdef __GNUC__
- #define COMPILER_VERSION "GCC"__VERSION__
- #else
- #define COMPILER_VERSION "Please put compiler version here (e.g. gcc 4.1)"
- #endif
-#endif
-#ifndef COMPILER_FLAGS
- #define COMPILER_FLAGS FLAGS_STR /* "Please put compiler flags here (e.g. -o3)" */
-#endif
-#ifndef MEM_LOCATION
- #define MEM_LOCATION "Please put data memory location here\n\t\t\t(e.g. code in flash, data on heap etc)"
- #define MEM_LOCATION_UNSPEC 1
-#endif
-
-/* Data Types:
-	To avoid compiler issues, define the data types that need ot be used for 8b, 16b and 32b in <core_portme.h>.
-
-	*Imprtant*:
-	ee_ptr_int needs to be the data type used to hold pointers, otherwise coremark may fail!!!
-*/
-typedef signed short ee_s16;
-typedef unsigned short ee_u16;
-typedef signed int ee_s32;
-typedef double ee_f32;
-typedef unsigned char ee_u8;
-typedef unsigned int ee_u32;
-//#if __has_feature(capabilities)
-#if 0
-typedef __intcap_t ee_ptr_int;
-#else
-typedef unsigned long ee_ptr_int;
-#endif
-typedef size_t ee_size_t;
-/* align an offset to point to a 32b value */
-#if __has_builtin(__builtin_align_up)
-#define align_mem(x) __builtin_align_up((x), 4)
-#else
-#define align_mem(x) (void *)(4 + (((ee_ptr_int)(x) - 1) & ~3))
-#endif
-
-/* Configuration: SEED_METHOD
-	Defines method to get seed values that cannot be computed at compile time.
-
-	Valid values:
-	SEED_ARG - from command line.
-	SEED_FUNC - from a system function.
-	SEED_VOLATILE - from volatile variables.
-*/
-#ifndef SEED_METHOD
-#define SEED_METHOD SEED_ARG
-#endif
-
-/* Configuration: MEM_METHOD
-	Defines method to get a block of memry.
-
-	Valid values:
-	MEM_MALLOC - for platforms that implement malloc and have malloc.h.
-	MEM_STATIC - to use a static memory array.
-	MEM_STACK - to allocate the data block on the stack (NYI).
-*/
-#ifndef MEM_METHOD
-#define MEM_METHOD MEM_MALLOC
-#endif
-
-/* Configuration: MULTITHREAD
-	Define for parallel execution
-
-	Valid values:
-	1 - only one context (default).
-	N>1 - will execute N copies in parallel.
-
-	Note:
-	If this flag is defined to more then 1, an implementation for launching parallel contexts must be defined.
-
-	Two sample implementations are provided. Use <USE_PTHREAD> or <USE_FORK> to enable them.
-
-	It is valid to have a different implementation of <core_start_parallel> and <core_end_parallel> in <core_portme.c>,
-	to fit a particular architecture.
-*/
-#ifndef MULTITHREAD
-#define MULTITHREAD 1
-#endif
-
-/* Configuration: USE_PTHREAD
-	Sample implementation for launching parallel contexts
-	This implementation uses pthread_thread_create and pthread_join.
-
-	Valid values:
-	0 - Do not use pthreads API.
-	1 - Use pthreads API
-
-	Note:
-	This flag only matters if MULTITHREAD has been defined to a value greater then 1.
-*/
-#ifndef USE_PTHREAD
-#define USE_PTHREAD 0
-#endif
-
-/* Configuration: USE_FORK
-	Sample implementation for launching parallel contexts
-	This implementation uses fork, waitpid, shmget,shmat and shmdt.
-
-	Valid values:
-	0 - Do not use fork API.
-	1 - Use fork API
-
-	Note:
-	This flag only matters if MULTITHREAD has been defined to a value greater then 1.
-*/
-#ifndef USE_FORK
-#define USE_FORK 0
-#endif
-
-/* Configuration: USE_SOCKET
-	Sample implementation for launching parallel contexts
-	This implementation uses fork, socket, sendto and recvfrom
-
-	Valid values:
-	0 - Do not use fork and sockets API.
-	1 - Use fork and sockets API
-
-	Note:
-	This flag only matters if MULTITHREAD has been defined to a value greater then 1.
-*/
-#ifndef USE_SOCKET
-#define USE_SOCKET 0
-#endif
-
-/* Configuration: MAIN_HAS_NOARGC
-	Needed if platform does not support getting arguments to main.
-
-	Valid values:
-	0 - argc/argv to main is supported
-	1 - argc/argv to main is not supported
-*/
-#ifndef MAIN_HAS_NOARGC
-#define MAIN_HAS_NOARGC 0
-#endif
-
-/* Configuration: MAIN_HAS_NORETURN
-	Needed if platform does not support returning a value from main.
-
-	Valid values:
-	0 - main returns an int, and return value will be 0.
-	1 - platform does not support returning a value from main
-*/
-#ifndef MAIN_HAS_NORETURN
-#define MAIN_HAS_NORETURN 0
-#endif
-
-/* Variable: default_num_contexts
-	Number of contexts to spawn in multicore context.
-	Override this global value to change number of contexts used.
-
-	Note:
-	This value may not be set higher then the <MULTITHREAD> define.
-
-	To experiment, you can set the <MULTITHREAD> define to the highest value expected, and use argc/argv in the <portable_init> to set this value from the command line.
-*/
-extern ee_u32 default_num_contexts;
-
-#if (MULTITHREAD>1)
-#if USE_PTHREAD
-	#include <pthread.h>
-	#define PARALLEL_METHOD "PThreads"
-#elif USE_FORK
-	#include <unistd.h>
-	#include <errno.h>
-	#include <sys/wait.h>
-	#include <sys/shm.h>
-	#include <string.h> /* for memcpy */
-	#define PARALLEL_METHOD "Fork"
-#elif USE_SOCKET
-	#include <sys/types.h>
-	#include <sys/socket.h>
-	#include <netinet/in.h>
-	#include <arpa/inet.h>
-	#include <sys/wait.h>
-	#include <stdio.h>
-	#include <stdlib.h>
-	#include <string.h>
-	#include <unistd.h>
-	#include <errno.h>
-	#define PARALLEL_METHOD "Sockets"
-#else
-	#define PARALLEL_METHOD "Proprietary"
-	#error "Please implement multicore functionality in core_portme.c to use multiple contexts."
-#endif /* Method for multithreading */
-#endif /* MULTITHREAD > 1 */
-
-typedef struct CORE_PORTABLE_S {
-#if (MULTITHREAD>1)
-	#if USE_PTHREAD
-	pthread_t thread;
-	#elif USE_FORK
-	pid_t pid;
-	int shmid;
-	void *shm;
-	#elif USE_SOCKET
-	pid_t pid;
-	int sock;
-	struct sockaddr_in sa;
-	#endif /* Method for multithreading */
-#endif /* MULTITHREAD>1 */
-	ee_u8	portable_id;
-} core_portable;
-
-/* target specific init/fini */
-void portable_init(core_portable *p, int *argc, char *argv[]);
-void portable_fini(core_portable *p);
-
-#if (SEED_METHOD==SEED_VOLATILE)
- #if (VALIDATION_RUN || PERFORMANCE_RUN || PROFILE_RUN)
-  #define RUN_TYPE_FLAG 1
- #else
-  #if (TOTAL_DATA_SIZE==1200)
-   #define PROFILE_RUN 1
-  #else
-   #define PERFORMANCE_RUN 1
-  #endif
- #endif
-#endif /* SEED_METHOD==SEED_VOLATILE */
-
-#endif /* CORE_PORTME_H */
diff --git a/sw/app/coremark/rtems/core_portme.mak b/sw/app/coremark/rtems/core_portme.mak
deleted file mode 100755
index 0675a7a..0000000
--- a/sw/app/coremark/rtems/core_portme.mak
+++ /dev/null
@@ -1,140 +0,0 @@
-# Copyright 2018 Embedded Microprocessor Benchmark Consortium (EEMBC)
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#    http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-# Original Author: Shay Gal-on
-
-#File: core_portme.mak
-
-# Flag: OUTFLAG
-#	Use this flag to define how to to get an executable (e.g -o)
-OUTFLAG= -o
-# Flag: CC
-#	Use this flag to define compiler to use
-CC?= riscv-rtems5-gcc
-# Flag: CFLAGS
-#	Use this flag to define compiler options. Note, you can add compiler options from the command line using XCFLAGS="other flags"
-PORT_CFLAGS = -O2
-FLAGS_STR = "$(PORT_CFLAGS) $(XCFLAGS) $(XLFLAGS) $(LFLAGS_END)"
-CFLAGS += $(PORT_CFLAGS) -I$(PORT_DIR) -I. -DFLAGS_STR=\"$(FLAGS_STR)\"
-#Flag: LFLAGS_END
-#	Define any libraries needed for linking or other flags that should come at the end of the link line (e.g. linker scripts).
-#	Note: On certain platforms, the default clock_gettime implementation is supported but requires linking of librt.
-#LFLAGS_END += -lrt
-# Flag: PORT_SRCS
-# Port specific source files can be added here
-PORT_SRCS = $(PORT_DIR)/core_portme.c $(PORT_DIR)/main.c
-# Flag: LOAD
-#	Define this flag if you need to load to a target, as in a cross compile environment.
-
-# Flag: RUN
-#	Define this flag if running does not consist of simple invocation of the binary.
-#	In a cross compile environment, you need to define this.
-
-#For flashing and using a tera term macro, you could use
-#LOAD = flash ADDR
-#RUN =  ttpmacro coremark.ttl
-
-#For copying to target and executing via SSH connection, you could use
-#LOAD = scp $(OUTFILE)  user@target:~
-#RUN = ssh user@target -c
-
-#For native compilation and execution
-LOAD = echo Loading done
-RUN =
-
-OEXT = .o
-EXE = .exe
-
-# Flag: SEPARATE_COMPILE
-# Define if you need to separate compilation from link stage.
-# In this case, you also need to define below how to create an object file, and how to link.
-ifdef SEPARATE_COMPILE
-
-#LD		= riscv-rtems5-gcc
-OBJOUT 	= -o
-LFLAGS 	=
-OFLAG 	= -o
-COUT 	= -c
-# Flag: PORT_OBJS
-# Port specific object files can be added here
-PORT_OBJS = $(PORT_DIR)/core_portme$(OEXT)
-PORT_CLEAN = *$(OEXT)
-
-$(OPATH)%$(OEXT) : %.c
-	$(CC) $(CFLAGS) $(XCFLAGS) $(COUT) $< $(OBJOUT) $@
-
-endif
-
-# Target: port_prebuild
-# Generate any files that are needed before actual build starts.
-# E.g. generate profile guidance files. Sample PGO generation for gcc enabled with PGO=1
-#  - First, check if PGO was defined on the command line, if so, need to add -fprofile-use to compile line.
-#  - Second, if PGO reference has not yet been generated, add a step to the prebuild that will build a profile-generate version and run it.
-#  Note - Using REBUILD=1
-#
-# Use make PGO=1 to invoke this sample processing.
-
-ifdef PGO
- ifeq (,$(findstring $(PGO),gen))
-  PGO_STAGE=build_pgo_gcc
-  CFLAGS+=-fprofile-use
- endif
- PORT_CLEAN+=*.gcda *.gcno gmon.out
-endif
-
-.PHONY: port_prebuild
-port_prebuild: $(PGO_STAGE)
-
-.PHONY: build_pgo_gcc
-build_pgo_gcc:
-	$(MAKE) PGO=gen XCFLAGS="$(XCFLAGS) -fprofile-generate -DTOTAL_DATA_SIZE=1200" ITERATIONS=10 gen_pgo_data REBUILD=1
-
-# Target: port_postbuild
-# Generate any files that are needed after actual build end.
-# E.g. change format to srec, bin, zip in order to be able to load into flash
-.PHONY: port_postbuild
-port_postbuild:
-
-# Target: port_postrun
-# 	Do platform specific after run stuff.
-#	E.g. reset the board, backup the logfiles etc.
-.PHONY: port_postrun
-port_postrun:
-
-# Target: port_prerun
-# 	Do platform specific after run stuff.
-#	E.g. reset the board, backup the logfiles etc.
-.PHONY: port_prerun
-port_prerun:
-
-# Target: port_postload
-# 	Do platform specific after load stuff.
-#	E.g. reset the reset power to the flash eraser
-.PHONY: port_postload
-port_postload:
-
-# Target: port_preload
-# 	Do platform specific before load stuff.
-#	E.g. reset the reset power to the flash eraser
-.PHONY: port_preload
-port_preload:
-
-# FLAG: OPATH
-# Path to the output folder. Default - current folder.
-OPATH = ./
-MKDIR = mkdir -p
-
-# FLAG: PERL
-# Define perl executable to calculate the geomean if running separate.
-PERL=/usr/bin/perl
diff --git a/sw/app/coremark/simple/core_portme.c b/sw/app/coremark/simple/core_portme.c
index b95e3b2..3762348 100644
--- a/sw/app/coremark/simple/core_portme.c
+++ b/sw/app/coremark/simple/core_portme.c
@@ -51,9 +51,9 @@ volatile ee_s32 seed5_volatile = 0;
    does not occur. If there are issues with the return value overflowing,
    increase this value.
         */
-#define NSECS_PER_SEC              CLOCKS_PER_SEC
-#define CORETIMETYPE               clock_t
-#define GETMYTIME(_t)              (*_t = clock())
+#define NSECS_PER_SEC              50000000
+#define CORETIMETYPE               long
+#define GETMYTIME(_t)              (*_t = read_csr(mcycle))
 #define MYTIMEDIFF(fin, ini)       ((fin) - (ini))
 #define TIMER_RES_DIVIDER          1
 #define SAMPLE_TIME_IMPLEMENTATION 1
@@ -127,7 +127,7 @@ ee_u32 default_num_contexts = 1;
 void
 portable_init(core_portable *p, int *argc, char *argv[])
 {
-    if (sizeof(ee_ptr_int) != sizeof(ee_u8 *))
+if (sizeof(ee_ptr_int) != sizeof(ee_u8 *))
     {
         ee_printf(
             "ERROR! Please define ee_ptr_int to a type that holds a "
diff --git a/sw/app/coremark/simple/core_portme.h b/sw/app/coremark/simple/core_portme.h
index dfd94cb..1da2522 100644
--- a/sw/app/coremark/simple/core_portme.h
+++ b/sw/app/coremark/simple/core_portme.h
@@ -22,6 +22,10 @@ Original Author: Shay Gal-on
 */
 #ifndef CORE_PORTME_H
 #define CORE_PORTME_H
+
+#ifdef __riscv
+#include "encoding.h"
+#endif
 /************************/
 /* Data types and settings */
 /************************/
@@ -36,14 +40,14 @@ Original Author: Shay Gal-on
         and implementation of functions thereof.
 */
 #ifndef HAS_TIME_H
-#define HAS_TIME_H 1
+#define HAS_TIME_H 0
 #endif
 /* Configuration : USE_CLOCK
         Define to 1 if platform has the time.h header file,
         and implementation of functions thereof.
 */
 #ifndef USE_CLOCK
-#define USE_CLOCK 1
+#define USE_CLOCK 0
 #endif
 /* Configuration : HAS_STDIO
         Define to 1 if the platform has stdio.h.
@@ -80,7 +84,7 @@ typedef clock_t CORE_TICKS;
     FLAGS_STR /* "Please put compiler flags here (e.g. -o3)" */
 #endif
 #ifndef MEM_LOCATION
-#define MEM_LOCATION "STACK"
+#define MEM_LOCATION "BRAM"
 #endif
 
 /* Data Types :
@@ -127,7 +131,7 @@ typedef size_t         ee_size_t;
         MEM_STACK - to allocate the data block on the stack (NYI).
 */
 #ifndef MEM_METHOD
-#define MEM_METHOD MEM_STACK
+#define MEM_METHOD MEM_STATIC
 #endif
 
 /* Configuration : MULTITHREAD
-- 
2.7.4

